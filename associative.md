<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/associative](./associative.md)

## associative package

## Classes

|  Class | Description |
|  --- | --- |
|  [ArraySet](./associative.arrayset.md) | An alternative set implementation to the native ES6 Set type. Uses customizable equality/equivalence predicate and so is more useful when dealing with structured data. Implements full API of native Set and by the default uses [equiv](./equiv.equiv.md) for equivalence checking.<!-- -->Additionally, the type also implements the <code>ICopy</code>, <code>IEmpty</code> and <code>IEquiv</code> interfaces itself. |
|  [ASparseSet](./associative.asparseset.md) | After "An Efficient Representation for Sparse Sets" Preston Briggs and Linda Torczon (1993)<!-- -->- [https://research.swtch.com/sparse](https://research.swtch.com/sparse) - [https://programmingpraxis.com/2012/03/09/sparse-sets/](https://programmingpraxis.com/2012/03/09/sparse-sets/) - [https://blog.molecular-matters.com/2013/07/24/adventures-in-data-oriented-design-part-3c-external-references/](https://blog.molecular-matters.com/2013/07/24/adventures-in-data-oriented-design-part-3c-external-references/) |
|  [EquivMap](./associative.equivmap.md) |  |
|  [HashMap](./associative.hashmap.md) | Configurable hash map implementation w/ ES6 Map API. Uses open addressing / linear probing to resolve key collisions. Supports any key types via mandatory user supplied hash function.<!-- -->See <code>HashMapOpts</code> for further configuration &amp; behavior details.
```ts
import { HashMap } from "@thi.ng/associative"
import { hash } from "@thi.ng/vectors"

m = new HashMap([], { hash })
m.set([1, 2], "a");
m.set([3, 4], "b");
m.set([1, 2], "c");
// HashMap { [ 1, 2 ] => 'c', [ 3, 4 ] => 'b' }

```
 |
|  [LLSet](./associative.llset.md) | Similar to <code>ArraySet</code>, this class is an alternative implementation of the native ES6 Set API using a [DCons](./dcons.dcons.md) linked list as backing store and a customizable value equality / equivalence predicate. By the default uses [equiv](./equiv.equiv.md) for equivalence checking.<!-- -->Additionally, the type also implements the <code>ICopy</code>, <code>IEmpty</code> and <code>IEquiv</code> interfaces itself. |
|  [SortedMap](./associative.sortedmap.md) |  |
|  [SortedSet](./associative.sortedset.md) | Sorted set implementation with standard ES6 Set API, customizable value equality and comparison semantics and additional functionality:<!-- -->- range queries (via <code>entries</code>, <code>keys</code>, <code>values</code>) - multiple value addition/deletion via <code>into()</code> and <code>disj()</code>Furthermore, this class implements the <code>ICopy</code>, IEmpty<code>, </code>ICompare<code> and </code>IEquiv<!-- -->\` interfaces defined by . The latter two allow instances to be used as keys themselves in other data types defined in this (and other) package(s).<!-- -->This set uses a [SortedMap](./associative.sortedmap.md) as backing store and therefore has the same resizing characteristics. |
|  [SparseSet16](./associative.sparseset16.md) |  |
|  [SparseSet32](./associative.sparseset32.md) |  |
|  [SparseSet8](./associative.sparseset8.md) |  |

## Functions

|  Function | Description |
|  --- | --- |
|  [differenceR()](./associative.differencer.md) | Reducer version of <code>difference</code>. If <code>src</code> is given returns the reduced difference of given inputs, else merely returns a reducer to be used with  /  functions. |
|  [differenceR(src)](./associative.differencer_1.md) |  |
|  [dissoc(map, keys)](./associative.dissoc.md) |  |
|  [dissoc(set, keys)](./associative.dissoc_1.md) |  |
|  [intersectionR()](./associative.intersectionr.md) | Reducer version of <code>intersection</code>. If <code>src</code> is given returns the reduced intersection of given inputs, else merely returns a reducer to be used with  /  functions. |
|  [intersectionR(src)](./associative.intersectionr_1.md) |  |
|  [into(dest, src)](./associative.into.md) | Adds elements from <code>src</code> iterable to <code>dest</code> Map or Set. |
|  [into(dest, src)](./associative.into_1.md) |  |
|  [unionR()](./associative.unionr.md) | Reducer version of <code>union</code>. If <code>src</code> is given returns the reduced union of given inputs, else merely returns a reducer to be used with  /  functions. |
|  [unionR(src)](./associative.unionr_1.md) |  |

## Variables

|  Variable | Description |
|  --- | --- |
|  [commonKeysMap](./associative.commonkeysmap.md) | Like <code>commonKeysObj()</code>, but for ES6 Maps. |
|  [commonKeysObj](./associative.commonkeysobj.md) | Returns array of keys present in both args, i.e. the set intersection of the given objects' key / property sets.
```ts
commonKeys({ a: 1, b: 2 }, { c: 10, b: 20, a: 30 })
// [ "a", "b" ]

```
 |
|  [difference](./associative.difference.md) | Computes the difference of sets <code>a - b</code> and writes results to new set or optionally given set <code>out</code> (assumed to be empty for correct results). |
|  [dissocObj](./associative.dissocobj.md) |  |
|  [indexed](./associative.indexed.md) | Takes an iterable of plain objects and array of indexing keys. Calls <code>selectKeysObj</code> on each value and uses returned objects as new keys to group original values. Returns a new <code>EquivMap</code> of sets.
```ts
indexed(
  new Set([{a: 1, b: 1}, {a: 1, b: 2}, {a: 1, b: 1, c: 2}]),
  ["a","b"]
)
// EquivMap {
//   { a: 1, b: 1 } => Set { { a: 1, b: 1 }, { a: 1, b: 1, c: 2 } },
//   { a: 1, b: 2 } => Set { { a: 1, b: 2 } } }

```
 |
|  [intersection](./associative.intersection.md) | Computes the intersection of sets <code>a</code> and <code>b</code> and writes results into new set or optionally given set <code>out</code> (assumed to be empty for correct results). If <code>out</code> is \*not\* given, the returned Set type will be that of <code>a</code> (provided it defines <code>Symbol.species</code>). |
|  [invertMap](./associative.invertmap.md) | Returns a new map in which the original values are used as keys and original keys as values. If <code>dest</code> is given, writes results in that map instead. Depending on the value type of <code>src</code> and/or if the inverted map should use custom key equality semantics as provided by the Map types in this package, you MUST provide a <code>dest</code> map, since the default <code>dest</code> will only be a standard ES6 Map.
```ts
invertMap(new Map(), new Map([["a", 1], ["b", 2]]));
// Map { 1 => 'a', 2 => 'b' }

```
 |
|  [invertObj](./associative.invertobj.md) | Returns a new object in which the original values are used as keys and original keys as values. If <code>dest</code> is given, writes results in that object instead.
```ts
invertObj({a: 1, b: 2})
// { '1': 'a', '2': 'b' }

```
 |
|  [join](./associative.join.md) | Computes the natural join between the two sets of relations. Each set is assumed to have plain objects as values with at least one of the keys present in both sides. Furthermore the objects in each set are assumed to have the same internal structure (i.e. sets of keys). Returns new set of same type as <code>a</code>.
```ts
join(
  new Set([
    {id: 1, name: "foo"},
    {id: 2, name: "bar"},
    {id: 3, name: "baz"}]),
  new Set([
    {id: 1, color: "red"},
    {id: 2, color: "blue"}])
)
// Set {
//   { id: 1, color: 'red', name: 'foo' },
//   { id: 2, color: 'blue', name: 'bar' }
// }

```
 |
|  [joinWith](./associative.joinwith.md) | Similar to <code>join()</code>, computes the join between two sets of relations, using the given keys in <code>kmap</code> only for joining and ignoring others. <code>kmap</code> can also be used to translate join keys in <code>b</code> where needed. Else, if no renaming is desired, the values in <code>kmap</code> should be the same as their respective keys, e.g. <code>{id: &quot;id&quot;}</code>. Returns new set of same type as <code>a</code>.
```ts
joinWith(
  new Set([
    {id: 1, name: "foo"},
    {id: 2, name: "bar"},
    {id: 3, name: "baz"}]),
  new Set([
    {type: 1, color: "red"},
    {type: 2, color: "blue"}]),
  {id: "type"}
)
// Set {
//   { type: 1, color: 'red', id: 1, name: 'foo' },
//   { type: 2, color: 'blue', id: 2, name: 'bar' } }

```
 |
|  [mergeApplyMap](./associative.mergeapplymap.md) | Similar to <code>mergeApplyObj()</code>, but for ES6 Maps instead of plain objects. |
|  [mergeApplyObj](./associative.mergeapplyobj.md) | Similar to <code>mergeObjWith()</code>, but only supports 2 args and any function values in <code>xs</code> will be called with respective value in <code>src</code> to produce a new / derived value for that key, i.e.
```ts
dest[k] = xs[k](src[k])

```
Returns new merged object and does not modify any of the inputs.
```ts
mergeApplyObj(
  {a: "hello", b: 23, c: 12},
  {a: (x) => x + " world", b: 42}
);
// { a: 'hello world', b: 42, c: 12 }

```
 |
|  [mergeDeepObj](./associative.mergedeepobj.md) |  |
|  [mergeMap](./associative.mergemap.md) | Merges all given maps in left-to-right order into <code>dest</code>. Returns <code>dest</code>. |
|  [mergeMapWith](./associative.mergemapwith.md) |  |
|  [mergeObj](./associative.mergeobj.md) | Merges all given objects in left-to-right order into <code>dest</code>. Returns <code>dest</code>. |
|  [mergeObjWith](./associative.mergeobjwith.md) |  |
|  [renameKeysMap](./associative.renamekeysmap.md) | Renames keys in <code>src</code> using mapping provided by key map <code>km</code>. Does support key swapping / swizzling. Does not modify original. |
|  [renameKeysObj](./associative.renamekeysobj.md) | Renames keys in <code>src</code> using mapping provided by key map <code>km</code>. Does support key swapping / swizzling. Does not modify original.
```
// swap a & b, rename c
renameKeysObj({a: 1, b: 2, c: 3}, {a: "b", b: "a", c: "cc"})
// {b: 1, a: 2, cc: 3}

```
 |
|  [selectKeysMap](./associative.selectkeysmap.md) | Returns a new map of same type as input only containing given keys (and only if they existed in the original map). |
|  [selectKeysObj](./associative.selectkeysobj.md) | Returns a new object only containing given keys (and only if they existed in the original). |
|  [sparseSet](./associative.sparseset.md) | Creates a new sparse set with given max. capacity (max ID + 1) and chooses most memory efficient implementation, e.g. if <code>n</code> &lt;<!-- -->= 256 returns a <code>SparseSet8</code> instance. |
|  [union](./associative.union.md) | Computes union of sets <code>a</code> and <code>b</code> and writes results to new set or optionally given set <code>out</code> (assumed to be empty for correct results). |
|  [withoutKeysMap](./associative.withoutkeysmap.md) |  |
|  [withoutKeysObj](./associative.withoutkeysobj.md) |  |

