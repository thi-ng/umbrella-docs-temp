<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/math](./math.md)

## math package

## Enumerations

|  Enumeration | Description |
|  --- | --- |
|  [Crossing](./math.crossing.md) |  |

## Variables

|  Variable | Description |
|  --- | --- |
|  [absDiff](./math.absdiff.md) |  |
|  [absInnerAngle](./math.absinnerangle.md) |  |
|  [absMax](./math.absmax.md) |  |
|  [absMin](./math.absmin.md) |  |
|  [absTheta](./math.abstheta.md) | Projects <code>theta</code> into \[0 .. 2π\] interval. |
|  [addi16](./math.addi16.md) |  |
|  [addi32](./math.addi32.md) |  |
|  [addi8](./math.addi8.md) |  |
|  [addu16](./math.addu16.md) |  |
|  [addu32](./math.addu32.md) |  |
|  [addu8](./math.addu8.md) |  |
|  [andi16](./math.andi16.md) |  |
|  [andi32](./math.andi32.md) |  |
|  [andi8](./math.andi8.md) |  |
|  [andu16](./math.andu16.md) |  |
|  [andu32](./math.andu32.md) |  |
|  [andu8](./math.andu8.md) |  |
|  [angleDist](./math.angledist.md) | Returns smallest absolute angle difference between <code>a</code> and <code>b</code>. Result will be in \[0 .. π\] interval. |
|  [atan2Abs](./math.atan2abs.md) | Like <code>Math.atan2</code>, but always returns angle in \[0 .. TAU) interval. |
|  [bounce](./math.bounce.md) |  |
|  [circular](./math.circular.md) | Circular interpolation: <code>sqrt(1 - (1 - t)^2)</code> |
|  [clamp](./math.clamp.md) | Clamps value <code>x</code> to given closed interval. |
|  [clamp01](./math.clamp01.md) |  |
|  [clamp11](./math.clamp11.md) |  |
|  [classifyCrossing](./math.classifycrossing.md) | Returns [Crossing](./math.crossing.md) classifier indicating the relationship of line A to line B. The optional epsilon value is used to determine if both lines are considered equal or flat.<!-- -->- [isCrossOver](./math.iscrossover.md) - [isCrossUnder](./math.iscrossunder.md) - [Crossing](./math.crossing.md) |
|  [cosine](./math.cosine.md) |  |
|  [cossin](./math.cossin.md) | Returns vector of <code>[cos(theta)*n, sin(theta)*n]</code>. |
|  [cot](./math.cot.md) | Cotangent. Approaches <code>±Infinity</code> for <code>theta</code> near multiples of π. |
|  [csc](./math.csc.md) | Cosecant. Approaches <code>±Infinity</code> for <code>theta</code> near multiples of π. |
|  [cubicPulse](./math.cubicpulse.md) |  |
|  [decimated](./math.decimated.md) |  |
|  [deg](./math.deg.md) | Converts angle to degrees. |
|  [DEG2RAD](./math.deg2rad.md) |  |
|  [derivative](./math.derivative.md) | Produces a new function which computes derivative of the given single-arg function. The extra optional arg <code>eps</code> is used to define the step width for computing derived values:<code>f'(x) = (f(x + eps) - f(x)) / eps</code>The original function is assumed to be fully differentiable in the interval the returned function is going to be used. No validity checks of any form are done.[https://en.wikipedia.org/wiki/Derivative\#Continuity\_and\_differentiability](https://en.wikipedia.org/wiki/Derivative#Continuity_and_differentiability) |
|  [divi16](./math.divi16.md) |  |
|  [divi32](./math.divi32.md) |  |
|  [divi8](./math.divi8.md) |  |
|  [divu16](./math.divu16.md) |  |
|  [divu32](./math.divu32.md) |  |
|  [divu8](./math.divu8.md) |  |
|  [ease](./math.ease.md) | HOF exponential easing.<!-- -->- <code>ease = 1</code> -<!-- -->&gt; linear - <code>ease &gt; 1</code> -<!-- -->&gt; ease in - <code>ease &lt; 1</code> -<!-- -->&gt; ease out |
|  [EPS](./math.eps.md) |  |
|  [eqDelta](./math.eqdelta.md) | Checks if <code>&#124;a - b&#124; &lt;= ε</code> and adapts given epsilon value to the given arguments:<!-- -->ε is factored with the largest absolute value of <code>a</code> or <code>b</code> (but never lesser than the given <code>eps</code> value):<code>ε = ε * max(1, &#124;a&#124;, &#124;b&#124;)</code> |
|  [eqDeltaFixed](./math.eqdeltafixed.md) | Similar to [eqDelta](./math.eqdelta.md)<!-- -->, but used given <code>eps</code> as is. |
|  [expStep](./math.expstep.md) | Exponential ramp with variable shape, e.g.<!-- -->- S-curve: k=8, n=4 - Step near 1.0: k=8, n=20 - Pulse: k=0.005, n=-10 - Ease-in: k=0.5, n=0.25 |
|  [fastCos](./math.fastcos.md) | Fast cosine approximation using [normCos](./math.normcos.md) (polynomial). Max. error \~0.00059693<!-- -->In \[0 .. 2π\] interval, approx. 18-20% faster than <code>Math.cos</code> on V8. |
|  [fastSin](./math.fastsin.md) | [fastCos](./math.fastcos.md) |
|  [fit](./math.fit.md) |  |
|  [fit01](./math.fit01.md) |  |
|  [fit10](./math.fit10.md) |  |
|  [fit11](./math.fit11.md) |  |
|  [fitClamped](./math.fitclamped.md) |  |
|  [fmod](./math.fmod.md) | Returns <code>a - b * floor(a/b)</code> |
|  [foldback](./math.foldback.md) | [http://www.musicdsp.org/showone.php?id=203](http://www.musicdsp.org/showone.php?id=203) |
|  [fract](./math.fract.md) |  |
|  [gain](./math.gain.md) |  |
|  [HALF\_PI](./math.half_pi.md) |  |
|  [impulse](./math.impulse.md) | HOF impulse generator. Peaks at <code>t=1/k</code> |
|  [inOpenRange](./math.inopenrange.md) | Returns true iff <code>x</code> is in open interval <code>(min .. max)</code> |
|  [inRange](./math.inrange.md) | Returns true iff <code>x</code> is in closed interval <code>[min .. max]</code> |
|  [INV\_HALF\_PI](./math.inv_half_pi.md) |  |
|  [INV\_PI](./math.inv_pi.md) |  |
|  [INV\_TAU](./math.inv_tau.md) |  |
|  [isCrossOver](./math.iscrossover.md) | Returns true if line A rises up over B. |
|  [isCrossUnder](./math.iscrossunder.md) | Returns true if line A rises up over B. |
|  [isMaxima](./math.ismaxima.md) | Returns true if <code>b</code> is a local maxima, i.e. iff a &lt; b and b &gt; c. |
|  [isMinima](./math.isminima.md) | Returns true if <code>b</code> is a local minima, i.e. iff a &gt; b and b &lt; c. |
|  [loc](./math.loc.md) | Law of Cosines. Takes length of two sides of a triangle and the inner angle (in radians) between them. Returns length of third side. |
|  [lshifti16](./math.lshifti16.md) |  |
|  [lshifti32](./math.lshifti32.md) |  |
|  [lshifti8](./math.lshifti8.md) |  |
|  [lshiftu16](./math.lshiftu16.md) |  |
|  [lshiftu32](./math.lshiftu32.md) |  |
|  [lshiftu8](./math.lshiftu8.md) |  |
|  [max2id](./math.max2id.md) |  |
|  [max3id](./math.max3id.md) |  |
|  [max4id](./math.max4id.md) |  |
|  [maximaIndex](./math.maximaindex.md) | Returns index of the first local &amp; internal maxima found in given <code>values</code> array, or -1 if no such maxima exists. The search range can be optionally defined via semi-open \[from, to) index interval. |
|  [maximaIndices](./math.maximaindices.md) | Returns an iterator yielding all maxima indices in given <code>values</code> array. The search range can be optionally defined via semi-open \[from, to) index interval. |
|  [min2id](./math.min2id.md) |  |
|  [min3id](./math.min3id.md) |  |
|  [min4id](./math.min4id.md) |  |
|  [minError](./math.minerror.md) | Recursively evaluates function <code>fn</code> for <code>res</code> uniformly spaced values <code>t</code> in the closed parametric interval <code>[start,end]</code> and computes corresponding sample values <code>p</code>. For each <code>p</code> then calls <code>error</code> function to compute the error to query target value <code>q</code> and eventually returns the <code>t</code> producing the overall minimum error. At each level of recursion the search interval is increasingly narrowed / centered around the best <code>t</code> of the current iteration.<!-- -->The search is terminated early if the best error value is less than <code>eps</code>.<!-- -->The interval end points <code>start</code> and <code>end</code> MUST be normalized values in the closed \[0,1\] interval. |
|  [minimaIndex](./math.minimaindex.md) | Returns index of the first local &amp; internal minima found in given <code>values</code> array, or -1 if no such minima exists. The search range can be optionally defined via semi-open \[from, to) index interval. |
|  [minimaIndices](./math.minimaindices.md) | Returns an iterator yielding all minima indices in given <code>values</code> array. The search range can be optionally defined via semi-open \[from, to) index interval. |
|  [mix](./math.mix.md) |  |
|  [mixBilinear](./math.mixbilinear.md) |  |
|  [mixCubic](./math.mixcubic.md) |  |
|  [mixCubicHermite](./math.mixcubichermite.md) | Computes cubic-hermite interpolation between <code>a</code> / <code>b</code> at normalized time <code>t</code> and using respective tangents <code>ta</code> / <code>tb</code>.[https://en.wikipedia.org/wiki/Cubic\_Hermite\_spline](https://en.wikipedia.org/wiki/Cubic_Hermite_spline)<!-- -->- [mixHermite](./math.mixhermite.md) - [tangentCardinal](./math.tangentcardinal.md) - [tangentDiff3](./math.tangentdiff3.md) |
|  [mixHermite](./math.mixhermite.md) | Returns hermite interpolation of <code>a, b, c, d</code> at normalized position <code>t</code>, where <code>a</code> and <code>d</code> are used as predecessor/successor of <code>b</code> / <code>c</code> and only inform the tangent of the interpolation curve. The interpolated result is that of <code>b</code> and <code>c</code>.<!-- -->Assumes all inputs are uniformly spaced. If that's not the case, use [mixCubicHermite](./math.mixcubichermite.md) with one of the tangent generators supporting non-uniform spacing of points.<!-- -->See: [https://www.desmos.com/calculator/j4gf8g9vkr](https://www.desmos.com/calculator/j4gf8g9vkr)<!-- -->Source: [https://www.musicdsp.org/en/latest/Other/93-hermite-interpollation.html](https://www.musicdsp.org/en/latest/Other/93-hermite-interpollation.html)<!-- -->- [mixCubicHermite](./math.mixcubichermite.md) - [tangentCardinal](./math.tangentcardinal.md) - [tangentDiff3](./math.tangentdiff3.md) |
|  [mixQuadratic](./math.mixquadratic.md) |  |
|  [muli16](./math.muli16.md) |  |
|  [muli32](./math.muli32.md) |  |
|  [muli8](./math.muli8.md) |  |
|  [mulu16](./math.mulu16.md) |  |
|  [mulu32](./math.mulu32.md) |  |
|  [mulu8](./math.mulu8.md) |  |
|  [norm](./math.norm.md) | Returns normalized value of <code>x</code> WRT to interval <code>a .. b</code>. If <code>a</code> equals <code>b</code>, returns 0. |
|  [normCos](./math.normcos.md) | Approximates cos(xπ) for x in \[-1,1\] |
|  [noti16](./math.noti16.md) |  |
|  [noti32](./math.noti32.md) |  |
|  [noti8](./math.noti8.md) |  |
|  [notu16](./math.notu16.md) |  |
|  [notu32](./math.notu32.md) |  |
|  [notu8](./math.notu8.md) |  |
|  [ori16](./math.ori16.md) |  |
|  [ori32](./math.ori32.md) |  |
|  [ori8](./math.ori8.md) |  |
|  [oru16](./math.oru16.md) |  |
|  [oru32](./math.oru32.md) |  |
|  [oru8](./math.oru8.md) |  |
|  [parabola](./math.parabola.md) |  |
|  [PHI](./math.phi.md) |  |
|  [PI](./math.pi.md) |  |
|  [quadrant](./math.quadrant.md) | Returns quadrant ID (0-3) of given angle (in radians). |
|  [QUARTER\_PI](./math.quarter_pi.md) |  |
|  [rad](./math.rad.md) | Converts angle to radians. |
|  [RAD2DEG](./math.rad2deg.md) |  |
|  [roundEps](./math.roundeps.md) | Only rounds <code>x</code> to nearest int if <code>fract(x)</code> &lt; <code>eps</code> or &gt; <code>1-eps</code>. |
|  [roundTo](./math.roundto.md) |  |
|  [rshifti16](./math.rshifti16.md) |  |
|  [rshifti32](./math.rshifti32.md) |  |
|  [rshifti8](./math.rshifti8.md) |  |
|  [rshiftu16](./math.rshiftu16.md) |  |
|  [rshiftu32](./math.rshiftu32.md) |  |
|  [rshiftu8](./math.rshiftu8.md) |  |
|  [sclamp](./math.sclamp.md) | Same as <code>smin(smax(x, min, k), max, k)</code>. |
|  [sec](./math.sec.md) | Secant. Approaches <code>±Infinity</code> for <code>theta</code> near π/2 ± nπ |
|  [sigmoid](./math.sigmoid.md) | Sigmoid function for inputs in \[0..1\] interval. |
|  [sigmoid11](./math.sigmoid11.md) | Sigmoid function for inputs in \[-1..+1\] interval. |
|  [sign](./math.sign.md) |  |
|  [signExtend16](./math.signextend16.md) |  |
|  [signExtend8](./math.signextend8.md) |  |
|  [simplifyRatio](./math.simplifyratio.md) |  |
|  [sinc](./math.sinc.md) |  |
|  [sincos](./math.sincos.md) | Returns vector of <code>[sin(theta)*n, cos(theta)*n]</code>. |
|  [SIXTH\_PI](./math.sixth_pi.md) |  |
|  [SIXTH](./math.sixth.md) |  |
|  [smax](./math.smax.md) | Smooth maximum. Note: Result values will be slightly larger than max value near max(a,b) + eps due to exponential decay. Higher <code>k</code> values reduce the error, but also reduce the smoothing. Recommended k=16.[https://en.wikipedia.org/wiki/Smooth\_maximum](https://en.wikipedia.org/wiki/Smooth_maximum) |
|  [smin](./math.smin.md) | See <code>smax()</code>. |
|  [smootherStep](./math.smootherstep.md) | Similar to [smoothStep](./math.smoothstep.md) but using different polynomial. |
|  [smoothStep](./math.smoothstep.md) | GLSL-style smoothStep threshold function. |
|  [solveCubic](./math.solvecubic.md) | Computes solutions for quadratic equation: <code>ax^3 + bx^2 + c*x + d = 0</code>. Returns array of solutions, both real &amp; imaginary. Note: <code>a</code> MUST NOT be zero. If the cubic term is missing (i.e. zero), use [solveQuadratic](./math.solvequadratic.md) or [solveLinear](./math.solvelinear.md) instead.[https://en.wikipedia.org/wiki/Cubic\_function](https://en.wikipedia.org/wiki/Cubic_function) |
|  [solveLinear](./math.solvelinear.md) | Computes solution for linear equation: <code>ax + b = 0</code>.<!-- -->Note: <code>a</code> MUST NOT be zero. |
|  [solveQuadratic](./math.solvequadratic.md) | Computes solutions for quadratic equation: <code>ax^2 + bx + c = 0</code>. Returns array of real solutions. Note: <code>a</code> MUST NOT be zero. If the quadratic term is missing, use [solveLinear](./math.solvelinear.md) instead.<!-- -->- [https://en.wikipedia.org/wiki/Quadratic\_function](https://en.wikipedia.org/wiki/Quadratic_function) - [https://en.wikipedia.org/wiki/Quadratic\_equation](https://en.wikipedia.org/wiki/Quadratic_equation) |
|  [SQRT2\_2](./math.sqrt2_2.md) |  |
|  [SQRT2\_3](./math.sqrt2_3.md) |  |
|  [SQRT2](./math.sqrt2.md) |  |
|  [SQRT3](./math.sqrt3.md) |  |
|  [step](./math.step.md) | Step/threshold function. |
|  [subi16](./math.subi16.md) |  |
|  [subi32](./math.subi32.md) |  |
|  [subi8](./math.subi8.md) |  |
|  [subu16](./math.subu16.md) |  |
|  [subu32](./math.subu32.md) |  |
|  [subu8](./math.subu8.md) |  |
|  [tangentCardinal](./math.tangentcardinal.md) | Helper function for [mixCubicHermite](./math.mixcubichermite.md)<!-- -->. Computes cardinal tangents based on point neighbors of a point B (not given), i.e. <code>a</code> (predecessor) and <code>c</code> (successor) and their times (defaults to uniformly spaced). The optional <code>tension</code> parameter can be used to scale the tangent where 0.0 produces a Cardinal spline tangent and 1.0 a Catmull-Rom (opposite to the Wikipedia ref).[https://en.wikipedia.org/wiki/Cubic\_Hermite\_spline\#Cardinal\_spline](https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline) |
|  [tangentDiff3](./math.tangentdiff3.md) | Helper function for [mixCubicHermite](./math.mixcubichermite.md)<!-- -->. Computes tangent for <code>curr</code>, based on 3-point finite difference, where <code>prev</code> &amp; <code>next</code> are <code>curr</code>'s neighbors and the <code>tX</code> the three points' respective time values. The latter are equally spaced by default (each 1.0 apart).<!-- -->Using this function with equal spacing of 1.0 and together with [mixCubicHermite](./math.mixcubichermite.md) will produce same results as the somewhat optimized variant [mixHermite](./math.mixhermite.md)<!-- -->.[https://en.wikipedia.org/wiki/Cubic\_Hermite\_spline\#Finite\_difference](https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference) |
|  [TAU](./math.tau.md) |  |
|  [THIRD\_PI](./math.third_pi.md) |  |
|  [THIRD](./math.third.md) |  |
|  [trunc](./math.trunc.md) |  |
|  [tween](./math.tween.md) | HOF interpolator. Takes a timing function <code>f</code> and interval <code>[from, to]</code>. Returns function which takes normalized time as single arg and returns interpolated value. |
|  [TWO\_THIRD](./math.two_third.md) |  |
|  [wrap](./math.wrap.md) |  |
|  [wrap01](./math.wrap01.md) |  |
|  [wrap11](./math.wrap11.md) |  |
|  [xori16](./math.xori16.md) |  |
|  [xori32](./math.xori32.md) |  |
|  [xori8](./math.xori8.md) |  |
|  [xoru16](./math.xoru16.md) |  |
|  [xoru32](./math.xoru32.md) |  |
|  [xoru8](./math.xoru8.md) |  |

