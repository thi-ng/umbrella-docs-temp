<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/vectors](./vectors.md)

## vectors package

## Classes

|  Class | Description |
|  --- | --- |
|  [AVec](./vectors.avec.md) |  |
|  [Vec2](./vectors.vec2.md) |  |
|  [Vec3](./vectors.vec3.md) |  |
|  [Vec4](./vectors.vec4.md) |  |

## Functions

|  Function | Description |
|  --- | --- |
|  [stridedValues(buf, num, start, stride)](./vectors.stridedvalues.md) |  |
|  [vecIterator(ctor, buf, num, start, cstride, estride)](./vectors.veciterator.md) |  |

## Interfaces

|  Interface | Description |
|  --- | --- |
|  [BVec](./vectors.bvec.md) |  |
|  [ICopyView](./vectors.icopyview.md) |  |
|  [IVector](./vectors.ivector.md) |  |
|  [MultiBVecOpRoV](./vectors.multibvecoprov.md) |  |
|  [MultiBVecOpV](./vectors.multibvecopv.md) |  |
|  [MultiBVecOpVN](./vectors.multibvecopvn.md) |  |
|  [MultiBVecOpVV](./vectors.multibvecopvv.md) |  |
|  [MultiCompareOp](./vectors.multicompareop.md) |  |
|  [MultiToBVecOpV](./vectors.multitobvecopv.md) |  |
|  [MultiVecOp](./vectors.multivecop.md) |  |
|  [MultiVecOpN](./vectors.multivecopn.md) |  |
|  [MultiVecOpNNO](./vectors.multivecopnno.md) |  |
|  [MultiVecOpOO](./vectors.multivecopoo.md) |  |
|  [MultiVecOpOOO](./vectors.multivecopooo.md) |  |
|  [MultiVecOpRoV](./vectors.multivecoprov.md) |  |
|  [MultiVecOpRoVV](./vectors.multivecoprovv.md) |  |
|  [MultiVecOpRoVVO](./vectors.multivecoprovvo.md) |  |
|  [MultiVecOpV](./vectors.multivecopv.md) |  |
|  [MultiVecOpVN](./vectors.multivecopvn.md) |  |
|  [MultiVecOpVNN](./vectors.multivecopvnn.md) |  |
|  [MultiVecOpVNV](./vectors.multivecopvnv.md) |  |
|  [MultiVecOpVO](./vectors.multivecopvo.md) |  |
|  [MultiVecOpVV](./vectors.multivecopvv.md) |  |
|  [MultiVecOpVVN](./vectors.multivecopvvn.md) |  |
|  [MultiVecOpVVV](./vectors.multivecopvvv.md) |  |
|  [MultiVecOpVVVVNN](./vectors.multivecopvvvvnn.md) |  |
|  [StridedVec](./vectors.stridedvec.md) |  |
|  [Vec](./vectors.vec.md) |  |
|  [VectorConstructor](./vectors.vectorconstructor.md) |  |

## Variables

|  Variable | Description |
|  --- | --- |
|  [abs](./vectors.abs.md) |  |
|  [abs2](./vectors.abs2.md) |  |
|  [abs3](./vectors.abs3.md) |  |
|  [abs4](./vectors.abs4.md) |  |
|  [acos](./vectors.acos.md) |  |
|  [acos2](./vectors.acos2.md) |  |
|  [acos3](./vectors.acos3.md) |  |
|  [acos4](./vectors.acos4.md) |  |
|  [add](./vectors.add.md) |  |
|  [add2](./vectors.add2.md) |  |
|  [add3](./vectors.add3.md) |  |
|  [add4](./vectors.add4.md) |  |
|  [addI](./vectors.addi.md) |  |
|  [addI2](./vectors.addi2.md) |  |
|  [addI3](./vectors.addi3.md) |  |
|  [addI4](./vectors.addi4.md) |  |
|  [addm](./vectors.addm.md) |  |
|  [addm2](./vectors.addm2.md) |  |
|  [addm3](./vectors.addm3.md) |  |
|  [addm4](./vectors.addm4.md) |  |
|  [addmN](./vectors.addmn.md) |  |
|  [addmN2](./vectors.addmn2.md) |  |
|  [addmN3](./vectors.addmn3.md) |  |
|  [addmN4](./vectors.addmn4.md) |  |
|  [addmNS2](./vectors.addmns2.md) |  |
|  [addmNS3](./vectors.addmns3.md) |  |
|  [addmNS4](./vectors.addmns4.md) |  |
|  [addmS2](./vectors.addms2.md) |  |
|  [addmS3](./vectors.addms3.md) |  |
|  [addmS4](./vectors.addms4.md) |  |
|  [addN](./vectors.addn.md) |  |
|  [addN2](./vectors.addn2.md) |  |
|  [addN3](./vectors.addn3.md) |  |
|  [addN4](./vectors.addn4.md) |  |
|  [addNI](./vectors.addni.md) |  |
|  [addNI2](./vectors.addni2.md) |  |
|  [addNI3](./vectors.addni3.md) |  |
|  [addNI4](./vectors.addni4.md) |  |
|  [addNS2](./vectors.addns2.md) |  |
|  [addNS3](./vectors.addns3.md) |  |
|  [addNS4](./vectors.addns4.md) |  |
|  [addNU](./vectors.addnu.md) |  |
|  [addNU2](./vectors.addnu2.md) |  |
|  [addNU3](./vectors.addnu3.md) |  |
|  [addNU4](./vectors.addnu4.md) |  |
|  [addS2](./vectors.adds2.md) |  |
|  [addS3](./vectors.adds3.md) |  |
|  [addS4](./vectors.adds4.md) |  |
|  [addU](./vectors.addu.md) |  |
|  [addU2](./vectors.addu2.md) |  |
|  [addU3](./vectors.addu3.md) |  |
|  [addU4](./vectors.addu4.md) |  |
|  [addW2](./vectors.addw2.md) |  |
|  [addW3](./vectors.addw3.md) |  |
|  [addW4](./vectors.addw4.md) |  |
|  [addW5](./vectors.addw5.md) |  |
|  [angleBetween2](./vectors.anglebetween2.md) |  |
|  [angleBetween3](./vectors.anglebetween3.md) |  |
|  [angleRatio](./vectors.angleratio.md) |  |
|  [ARGS\_V](./vectors.args_v.md) |  |
|  [ARGS\_VN](./vectors.args_vn.md) |  |
|  [ARGS\_VNV](./vectors.args_vnv.md) |  |
|  [ARGS\_VV](./vectors.args_vv.md) |  |
|  [ARGS\_VVN](./vectors.args_vvn.md) |  |
|  [ARGS\_VVV](./vectors.args_vvv.md) |  |
|  [asin](./vectors.asin.md) |  |
|  [asin2](./vectors.asin2.md) |  |
|  [asin3](./vectors.asin3.md) |  |
|  [asin4](./vectors.asin4.md) |  |
|  [asVec2](./vectors.asvec2.md) |  |
|  [asVec3](./vectors.asvec3.md) |  |
|  [asVec4](./vectors.asvec4.md) |  |
|  [atan\_2](./vectors.atan_2.md) |  |
|  [atan\_22](./vectors.atan_22.md) |  |
|  [atan\_23](./vectors.atan_23.md) |  |
|  [atan\_24](./vectors.atan_24.md) |  |
|  [atan](./vectors.atan.md) |  |
|  [atan2](./vectors.atan2.md) |  |
|  [atan3](./vectors.atan3.md) |  |
|  [atan4](./vectors.atan4.md) |  |
|  [bisect2](./vectors.bisect2.md) |  |
|  [bitAndI](./vectors.bitandi.md) |  |
|  [bitAndI2](./vectors.bitandi2.md) |  |
|  [bitAndI3](./vectors.bitandi3.md) |  |
|  [bitAndI4](./vectors.bitandi4.md) |  |
|  [bitAndNI](./vectors.bitandni.md) |  |
|  [bitAndNI2](./vectors.bitandni2.md) |  |
|  [bitAndNI3](./vectors.bitandni3.md) |  |
|  [bitAndNI4](./vectors.bitandni4.md) |  |
|  [bitAndNU](./vectors.bitandnu.md) |  |
|  [bitAndNU2](./vectors.bitandnu2.md) |  |
|  [bitAndNU3](./vectors.bitandnu3.md) |  |
|  [bitAndNU4](./vectors.bitandnu4.md) |  |
|  [bitAndU](./vectors.bitandu.md) |  |
|  [bitAndU2](./vectors.bitandu2.md) |  |
|  [bitAndU3](./vectors.bitandu3.md) |  |
|  [bitAndU4](./vectors.bitandu4.md) |  |
|  [bitNotI](./vectors.bitnoti.md) |  |
|  [bitNotI2](./vectors.bitnoti2.md) |  |
|  [bitNotI3](./vectors.bitnoti3.md) |  |
|  [bitNotI4](./vectors.bitnoti4.md) |  |
|  [bitNotU](./vectors.bitnotu.md) |  |
|  [bitNotU2](./vectors.bitnotu2.md) |  |
|  [bitNotU3](./vectors.bitnotu3.md) |  |
|  [bitNotU4](./vectors.bitnotu4.md) |  |
|  [bitOrI](./vectors.bitori.md) |  |
|  [bitOrI2](./vectors.bitori2.md) |  |
|  [bitOrI3](./vectors.bitori3.md) |  |
|  [bitOrI4](./vectors.bitori4.md) |  |
|  [bitOrNI](./vectors.bitorni.md) |  |
|  [bitOrNI2](./vectors.bitorni2.md) |  |
|  [bitOrNI3](./vectors.bitorni3.md) |  |
|  [bitOrNI4](./vectors.bitorni4.md) |  |
|  [bitOrNU](./vectors.bitornu.md) |  |
|  [bitOrNU2](./vectors.bitornu2.md) |  |
|  [bitOrNU3](./vectors.bitornu3.md) |  |
|  [bitOrNU4](./vectors.bitornu4.md) |  |
|  [bitOrU](./vectors.bitoru.md) |  |
|  [bitOrU2](./vectors.bitoru2.md) |  |
|  [bitOrU3](./vectors.bitoru3.md) |  |
|  [bitOrU4](./vectors.bitoru4.md) |  |
|  [bitXorI](./vectors.bitxori.md) |  |
|  [bitXorI2](./vectors.bitxori2.md) |  |
|  [bitXorI3](./vectors.bitxori3.md) |  |
|  [bitXorI4](./vectors.bitxori4.md) |  |
|  [bitXorNI](./vectors.bitxorni.md) |  |
|  [bitXorNI2](./vectors.bitxorni2.md) |  |
|  [bitXorNI3](./vectors.bitxorni3.md) |  |
|  [bitXorNI4](./vectors.bitxorni4.md) |  |
|  [bitXorNU](./vectors.bitxornu.md) |  |
|  [bitXorNU2](./vectors.bitxornu2.md) |  |
|  [bitXorNU3](./vectors.bitxornu3.md) |  |
|  [bitXorNU4](./vectors.bitxornu4.md) |  |
|  [bitXorU](./vectors.bitxoru.md) |  |
|  [bitXorU2](./vectors.bitxoru2.md) |  |
|  [bitXorU3](./vectors.bitxoru3.md) |  |
|  [bitXorU4](./vectors.bitxoru4.md) |  |
|  [cartesian](./vectors.cartesian.md) | Converts polar vector <code>v</code> to cartesian coordinates and adds optional <code>offset</code>. See [polar](./vectors.polar.md) for reverse operation. If <code>out</code> is null, modifies <code>v</code> in place. |
|  [cartesian2](./vectors.cartesian2.md) | Converts 2D polar vector <code>v</code> to cartesian coordinates and adds optional <code>offset</code>. See [polar](./vectors.polar.md) for reverse operation. If <code>out</code> is null, modifies <code>v</code> in place. |
|  [cartesian3](./vectors.cartesian3.md) | Converts 3D polar vector <code>v</code> to cartesian coordinates and adds optional <code>offset</code>. See [polar](./vectors.polar.md) for reverse operation. If <code>out</code> is null, modifies <code>v</code> in place. |
|  [ceil](./vectors.ceil.md) |  |
|  [ceil2](./vectors.ceil2.md) |  |
|  [ceil3](./vectors.ceil3.md) |  |
|  [ceil4](./vectors.ceil4.md) |  |
|  [clamp](./vectors.clamp.md) |  |
|  [clamp01\_2](./vectors.clamp01_2.md) |  |
|  [clamp01\_3](./vectors.clamp01_3.md) |  |
|  [clamp01\_4](./vectors.clamp01_4.md) |  |
|  [clamp01](./vectors.clamp01.md) |  |
|  [clamp11\_2](./vectors.clamp11_2.md) |  |
|  [clamp11\_3](./vectors.clamp11_3.md) |  |
|  [clamp11\_4](./vectors.clamp11_4.md) |  |
|  [clamp11](./vectors.clamp11.md) |  |
|  [clamp2](./vectors.clamp2.md) |  |
|  [clamp3](./vectors.clamp3.md) |  |
|  [clamp4](./vectors.clamp4.md) |  |
|  [clampN](./vectors.clampn.md) |  |
|  [clampN2](./vectors.clampn2.md) |  |
|  [clampN3](./vectors.clampn3.md) |  |
|  [clampN4](./vectors.clampn4.md) |  |
|  [clockwise2](./vectors.clockwise2.md) | Returns true, if the triangle <code>a</code>, <code>b</code>, <code>c</code> is in clockwise order, i.e. if <code>corner2(a,b,c)</code> returned -1. |
|  [comparator2](./vectors.comparator2.md) | Returns a new 2D vector comparator using given component order. The comparator returns the signed index+1 of the first differing component, e.g. if order is <code>0,1</code>, a return value of -2 means that <code>a.y &lt; b.y</code>. |
|  [comparator3](./vectors.comparator3.md) | Returns a new 3D vector comparator using given component order. The comparator returns the signed index+1 of the first differing component, e.g. if order is <code>0,1,2</code>, a return value of -3 means that <code>a.z &lt; b.z</code>. |
|  [comparator4](./vectors.comparator4.md) | Returns a new 4D vector comparator using given component order. The comparator returns the signed index+1 of the first differing component, e.g. if order is <code>0,1,2,3</code>, a return value of -4 means that <code>a.w &lt; b.w</code>. |
|  [compile](./vectors.compile.md) |  |
|  [compileG](./vectors.compileg.md) |  |
|  [compileGHOF](./vectors.compileghof.md) |  |
|  [compileHOF](./vectors.compilehof.md) |  |
|  [copy](./vectors.copy.md) |  |
|  [copyVectors](./vectors.copyvectors.md) |  |
|  [corner2](./vectors.corner2.md) | Syntax sugar for <code>sign(signedArea2(a, b, c))</code>.<!-- -->- [sign](./math.sign.md) - [signedArea2](./vectors.signedarea2.md) |
|  [cos](./vectors.cos.md) |  |
|  [cos2](./vectors.cos2.md) |  |
|  [cos3](./vectors.cos3.md) |  |
|  [cos4](./vectors.cos4.md) |  |
|  [cosh](./vectors.cosh.md) |  |
|  [cosh2](./vectors.cosh2.md) |  |
|  [cosh3](./vectors.cosh3.md) |  |
|  [cosh4](./vectors.cosh4.md) |  |
|  [cross2](./vectors.cross2.md) |  |
|  [cross3](./vectors.cross3.md) |  |
|  [crossS2](./vectors.crosss2.md) |  |
|  [crossS3](./vectors.crosss3.md) |  |
|  [declareIndex](./vectors.declareindex.md) |  |
|  [declareIndices](./vectors.declareindices.md) |  |
|  [DEFAULT\_OUT](./vectors.default_out.md) |  |
|  [defaultOut](./vectors.defaultout.md) |  |
|  [defBitOp](./vectors.defbitop.md) |  |
|  [defBitOpN](./vectors.defbitopn.md) |  |
|  [defFnOp](./vectors.deffnop.md) |  |
|  [defHofOp](./vectors.defhofop.md) |  |
|  [defHofOpS](./vectors.defhofops.md) |  |
|  [defMathOp](./vectors.defmathop.md) |  |
|  [defMathOpN](./vectors.defmathopn.md) |  |
|  [defOp](./vectors.defop.md) |  |
|  [defOpS](./vectors.defops.md) |  |
|  [degrees](./vectors.degrees.md) |  |
|  [degrees2](./vectors.degrees2.md) |  |
|  [degrees3](./vectors.degrees3.md) |  |
|  [degrees4](./vectors.degrees4.md) |  |
|  [direction](./vectors.direction.md) | Computes direction vector <code>a</code> -<!-- -->&gt; <code>b</code>, normalized to length <code>n</code> (default 1). |
|  [dist](./vectors.dist.md) |  |
|  [distChebyshev](./vectors.distchebyshev.md) |  |
|  [distChebyshev2](./vectors.distchebyshev2.md) |  |
|  [distChebyshev3](./vectors.distchebyshev3.md) |  |
|  [distChebyshev4](./vectors.distchebyshev4.md) |  |
|  [distManhattan](./vectors.distmanhattan.md) |  |
|  [distManhattan2](./vectors.distmanhattan2.md) |  |
|  [distManhattan3](./vectors.distmanhattan3.md) |  |
|  [distManhattan4](./vectors.distmanhattan4.md) |  |
|  [distSq](./vectors.distsq.md) |  |
|  [distSq2](./vectors.distsq2.md) |  |
|  [distSq3](./vectors.distsq3.md) |  |
|  [distSq4](./vectors.distsq4.md) |  |
|  [div](./vectors.div.md) |  |
|  [div2](./vectors.div2.md) |  |
|  [div3](./vectors.div3.md) |  |
|  [div4](./vectors.div4.md) |  |
|  [divI](./vectors.divi.md) |  |
|  [divI2](./vectors.divi2.md) |  |
|  [divI3](./vectors.divi3.md) |  |
|  [divI4](./vectors.divi4.md) |  |
|  [divN](./vectors.divn.md) |  |
|  [divN2](./vectors.divn2.md) |  |
|  [divN3](./vectors.divn3.md) |  |
|  [divN4](./vectors.divn4.md) |  |
|  [divNI](./vectors.divni.md) |  |
|  [divNI2](./vectors.divni2.md) |  |
|  [divNI3](./vectors.divni3.md) |  |
|  [divNI4](./vectors.divni4.md) |  |
|  [divNS2](./vectors.divns2.md) |  |
|  [divNS3](./vectors.divns3.md) |  |
|  [divNS4](./vectors.divns4.md) |  |
|  [divNU](./vectors.divnu.md) |  |
|  [divNU2](./vectors.divnu2.md) |  |
|  [divNU3](./vectors.divnu3.md) |  |
|  [divNU4](./vectors.divnu4.md) |  |
|  [divS2](./vectors.divs2.md) |  |
|  [divS3](./vectors.divs3.md) |  |
|  [divS4](./vectors.divs4.md) |  |
|  [divU](./vectors.divu.md) |  |
|  [divU2](./vectors.divu2.md) |  |
|  [divU3](./vectors.divu3.md) |  |
|  [divU4](./vectors.divu4.md) |  |
|  [DOT\_G](./vectors.dot_g.md) |  |
|  [dot](./vectors.dot.md) |  |
|  [DOT](./vectors.dot.md) |  |
|  [dot2](./vectors.dot2.md) |  |
|  [dot3](./vectors.dot3.md) |  |
|  [dot4](./vectors.dot4.md) |  |
|  [dotC4](./vectors.dotc4.md) | Returns pairwise product sum of given components. |
|  [dotC6](./vectors.dotc6.md) | Returns pairwise product sum of given components. |
|  [dotC8](./vectors.dotc8.md) | Returns pairwise product sum of given components. |
|  [dotS2](./vectors.dots2.md) |  |
|  [dotS3](./vectors.dots3.md) |  |
|  [dotS4](./vectors.dots4.md) |  |
|  [empty](./vectors.empty.md) |  |
|  [eq](./vectors.eq.md) |  |
|  [eq2](./vectors.eq2.md) |  |
|  [eq3](./vectors.eq3.md) |  |
|  [eq4](./vectors.eq4.md) |  |
|  [eqDelta](./vectors.eqdelta.md) |  |
|  [eqDelta2](./vectors.eqdelta2.md) |  |
|  [eqDelta3](./vectors.eqdelta3.md) |  |
|  [eqDelta4](./vectors.eqdelta4.md) |  |
|  [eqDeltaArray](./vectors.eqdeltaarray.md) |  |
|  [eqDeltaS](./vectors.eqdeltas.md) | Similar to [eq](./vectors.eq.md)<!-- -->, but takes tolerance <code>eps</code> into account for equality checks. |
|  [every](./vectors.every.md) | Returns returns true if all vector components in <code>v</code> are truthy. |
|  [every2](./vectors.every2.md) |  |
|  [every3](./vectors.every3.md) |  |
|  [every4](./vectors.every4.md) |  |
|  [exp\_2](./vectors.exp_2.md) |  |
|  [exp\_22](./vectors.exp_22.md) |  |
|  [exp\_23](./vectors.exp_23.md) |  |
|  [exp\_24](./vectors.exp_24.md) |  |
|  [exp](./vectors.exp.md) |  |
|  [exp2](./vectors.exp2.md) |  |
|  [exp3](./vectors.exp3.md) |  |
|  [exp4](./vectors.exp4.md) |  |
|  [faceForward](./vectors.faceforward.md) |  |
|  [fill](./vectors.fill.md) | Fills Vec2/3/4 view based buffer, supporting arbitrary component and element layouts of both the input and output buffers. The <code>out</code> vector is used as write cursor over the underlying buffer and will be filled with the components of vector <code>v</code>. |
|  [fit](./vectors.fit.md) |  |
|  [fit01\_2](./vectors.fit01_2.md) |  |
|  [fit01\_3](./vectors.fit01_3.md) |  |
|  [fit01\_4](./vectors.fit01_4.md) |  |
|  [fit01](./vectors.fit01.md) |  |
|  [fit11\_2](./vectors.fit11_2.md) |  |
|  [fit11\_3](./vectors.fit11_3.md) |  |
|  [fit11\_4](./vectors.fit11_4.md) |  |
|  [fit11](./vectors.fit11.md) |  |
|  [fit2](./vectors.fit2.md) |  |
|  [fit3](./vectors.fit3.md) |  |
|  [fit4](./vectors.fit4.md) |  |
|  [floor](./vectors.floor.md) |  |
|  [floor2](./vectors.floor2.md) |  |
|  [floor3](./vectors.floor3.md) |  |
|  [floor4](./vectors.floor4.md) |  |
|  [fmod](./vectors.fmod.md) |  |
|  [fmod2](./vectors.fmod2.md) |  |
|  [fmod3](./vectors.fmod3.md) |  |
|  [fmod4](./vectors.fmod4.md) |  |
|  [fmodN](./vectors.fmodn.md) |  |
|  [fmodN2](./vectors.fmodn2.md) |  |
|  [fmodN3](./vectors.fmodn3.md) |  |
|  [fmodN4](./vectors.fmodn4.md) |  |
|  [FN\_N](./vectors.fn_n.md) |  |
|  [FN](./vectors.fn.md) |  |
|  [FN2](./vectors.fn2.md) |  |
|  [FN3](./vectors.fn3.md) |  |
|  [FN5](./vectors.fn5.md) |  |
|  [fract](./vectors.fract.md) |  |
|  [fract2](./vectors.fract2.md) |  |
|  [fract3](./vectors.fract3.md) |  |
|  [fract4](./vectors.fract4.md) |  |
|  [fromHomogeneous](./vectors.fromhomogeneous.md) |  |
|  [fromHomogeneous3](./vectors.fromhomogeneous3.md) |  |
|  [fromHomogeneous4](./vectors.fromhomogeneous4.md) |  |
|  [gt](./vectors.gt.md) |  |
|  [gt2](./vectors.gt2.md) |  |
|  [gt3](./vectors.gt3.md) |  |
|  [gt4](./vectors.gt4.md) |  |
|  [gte](./vectors.gte.md) |  |
|  [gte2](./vectors.gte2.md) |  |
|  [gte3](./vectors.gte3.md) |  |
|  [gte4](./vectors.gte4.md) |  |
|  [gvec](./vectors.gvec.md) | Wrapper for strided, arbitrary length vectors. Wraps given buffer in ES6 <code>Proxy</code> with custom property getters/setters and implements the following interfaces:<!-- -->- <code>Iterable</code> (ES6) - [ICopy](./api.icopy.md) - [IEmpty](./api.iempty.md) - [IEqualsDelta](./api.iequalsdelta.md) - [IVector](./vectors.ivector.md) - <code>Object.toString()</code>Read/write access for the following properties:<!-- -->- array indices in the \[0 .. <code>size</code>) interval - <code>offset</code> - start index - <code>stride</code> - component stride - <code>buf</code> - backing buffer (readonly) - <code>length</code> - vector size<!-- -->Array index access uses bounds checking against the \[0 .. <code>size</code>) interval, but, for performance reasons, \*\*not\*\* against the actual wrapped buffer.<!-- -->Note: ES6 proxies are \~10x slower than standard array accesses. If several computations are to be performed on such vectors it will be much more efficient to first copy them to compact arrays and then copy result back if needed.
```
// 3D vector w/ stride length of 4
a = gvec([1,0,0,0,2,0,0,0,3,0,0,0], 3, 0, 4);
a[0] // 1
a[1] // 2
a[2] // 3

a.stride
// 4

[...a]
// [1, 2, 3]

a.toString()
// "[1,2,3]"

add([], a, a)
// [2, 4, 6]

copy(a)
// [1, 2, 3]

a.copyView()
// Proxy [ [ 1, 0, 2, 0, 3, 0 ], ... }

eqDelta(a, [1, 2, 3])
// true

```
 |
|  [hash](./vectors.hash.md) | Returns an unsigned 32-bit hash code for the given vector. The hash is the reduction of <code>hash = H * hash + murmur(x)</code>, where <code>murmur(x)</code> is the partial Murmur3 hash of a single vector component's bitwise representation and <code>H</code> an optional hash factor, by default Knuth's 0x9e3779b1 (see TAOCP, section 6.4, page 516). If the vector <code>v</code> is empty (length 0), the function returns -1.<!-- -->Hashes for zero-vectors:<!-- -->- <code>[0]</code>: 1209856430 - <code>[0, 0]</code>: 3623989185 - <code>[0, 0, 0]</code>: 4192292821 - <code>[0, 0, 0, 0]</code>: 2558592725<!-- -->Hash collisions:
```
// integer grid coords
uniq = tx.transduce(tx.map(v.hash32), tx.conj(), tx.range2d(0x1000, 0x1000)).size
// 16744420

// collision rate
(1 - uniq / (0x1000 ** 2)) * 100
// 0.1955 %

// normalized grid coords
uniq = tx.transduce(
  tx.map(v.hash32),
  tx.conj(),
  tx.permutations(tx.normRange(1000), tx.normRange(1000))
).size
// 1001895

// collision rate
(1 - uniq / (1001 ** 2)) * 100
// 0.0106 %

```
- [https://github.com/thi-ng/c-thing/blob/master/src/math/hashfn.c](https://github.com/thi-ng/c-thing/blob/master/src/math/hashfn.c) - [@thi.ng/morton](./morton.md) for Z-curve ordered hashing |
|  [heading](./vectors.heading.md) | Same as [headingXY](./vectors.headingxy.md) |
|  [headingSegment](./vectors.headingsegment.md) | Same as [headingSegmentXY](./vectors.headingsegmentxy.md)<!-- -->. |
|  [headingSegmentXY](./vectors.headingsegmentxy.md) | Computes direction angle (in radians) of line segment <code>a</code> -<!-- -->&gt; <code>b</code> in XY plane. |
|  [headingSegmentXZ](./vectors.headingsegmentxz.md) | Computes direction angle (in radians) of line segment <code>a</code> -<!-- -->&gt; <code>b</code> in XZ plane. |
|  [headingSegmentYZ](./vectors.headingsegmentyz.md) | Computes direction angle (in radians) of line segment <code>a</code> -<!-- -->&gt; <code>b</code> in ZY plane. |
|  [headingXY](./vectors.headingxy.md) | Returns orientation angle (in radians) of vector <code>a</code> in XY plane. |
|  [headingXZ](./vectors.headingxz.md) | Returns orientation angle (in radians) of vector <code>a</code> in XZ plane. |
|  [headingYZ](./vectors.headingyz.md) | Returns orientation angle (in radians) of vector <code>a</code> in ZY plane. |
|  [intoBuffer](./vectors.intobuffer.md) | Writes given <code>src</code> vector values into mapped <code>ArrayBuffer</code> of stated <code>type</code> and from given offset &amp; stride/spacing.[mapBuffer](./vectors.mapbuffer.md) |
|  [intoStridedBuffer](./vectors.intostridedbuffer.md) |  |
|  [invert](./vectors.invert.md) |  |
|  [invert2](./vectors.invert2.md) |  |
|  [invert3](./vectors.invert3.md) |  |
|  [invert4](./vectors.invert4.md) |  |
|  [invSqrt](./vectors.invsqrt.md) |  |
|  [invSqrt2](./vectors.invsqrt2.md) |  |
|  [invSqrt3](./vectors.invsqrt3.md) |  |
|  [invSqrt4](./vectors.invsqrt4.md) |  |
|  [isInArray](./vectors.isinarray.md) |  |
|  [isInf](./vectors.isinf.md) |  |
|  [isInf2](./vectors.isinf2.md) |  |
|  [isInf3](./vectors.isinf3.md) |  |
|  [isInf4](./vectors.isinf4.md) |  |
|  [isNaN](./vectors.isnan.md) |  |
|  [isNaN2](./vectors.isnan2.md) |  |
|  [isNaN3](./vectors.isnan3.md) |  |
|  [isNaN4](./vectors.isnan4.md) |  |
|  [jitter](./vectors.jitter.md) |  |
|  [limit](./vectors.limit.md) |  |
|  [log\_2](./vectors.log_2.md) |  |
|  [log\_22](./vectors.log_22.md) |  |
|  [log\_23](./vectors.log_23.md) |  |
|  [log\_24](./vectors.log_24.md) |  |
|  [log](./vectors.log.md) |  |
|  [log2](./vectors.log2.md) |  |
|  [log3](./vectors.log3.md) |  |
|  [log4](./vectors.log4.md) |  |
|  [logicAnd](./vectors.logicand.md) |  |
|  [logicAnd2](./vectors.logicand2.md) |  |
|  [logicAnd3](./vectors.logicand3.md) |  |
|  [logicAnd4](./vectors.logicand4.md) |  |
|  [logicAndN](./vectors.logicandn.md) |  |
|  [logicAndN2](./vectors.logicandn2.md) |  |
|  [logicAndN3](./vectors.logicandn3.md) |  |
|  [logicAndN4](./vectors.logicandn4.md) |  |
|  [logicNot](./vectors.logicnot.md) |  |
|  [logicNot2](./vectors.logicnot2.md) |  |
|  [logicNot3](./vectors.logicnot3.md) |  |
|  [logicNot4](./vectors.logicnot4.md) |  |
|  [logicOr](./vectors.logicor.md) |  |
|  [logicOr2](./vectors.logicor2.md) |  |
|  [logicOr3](./vectors.logicor3.md) |  |
|  [logicOr4](./vectors.logicor4.md) |  |
|  [logicOrN](./vectors.logicorn.md) |  |
|  [logicOrN2](./vectors.logicorn2.md) |  |
|  [logicOrN3](./vectors.logicorn3.md) |  |
|  [logicOrN4](./vectors.logicorn4.md) |  |
|  [lshiftI](./vectors.lshifti.md) |  |
|  [lshiftI2](./vectors.lshifti2.md) |  |
|  [lshiftI3](./vectors.lshifti3.md) |  |
|  [lshiftI4](./vectors.lshifti4.md) |  |
|  [lshiftNI](./vectors.lshiftni.md) |  |
|  [lshiftNI2](./vectors.lshiftni2.md) |  |
|  [lshiftNI3](./vectors.lshiftni3.md) |  |
|  [lshiftNI4](./vectors.lshiftni4.md) |  |
|  [lshiftNU](./vectors.lshiftnu.md) |  |
|  [lshiftNU2](./vectors.lshiftnu2.md) |  |
|  [lshiftNU3](./vectors.lshiftnu3.md) |  |
|  [lshiftNU4](./vectors.lshiftnu4.md) |  |
|  [lshiftU](./vectors.lshiftu.md) |  |
|  [lshiftU2](./vectors.lshiftu2.md) |  |
|  [lshiftU3](./vectors.lshiftu3.md) |  |
|  [lshiftU4](./vectors.lshiftu4.md) |  |
|  [lt](./vectors.lt.md) |  |
|  [lt2](./vectors.lt2.md) |  |
|  [lt3](./vectors.lt3.md) |  |
|  [lt4](./vectors.lt4.md) |  |
|  [lte](./vectors.lte.md) |  |
|  [lte2](./vectors.lte2.md) |  |
|  [lte3](./vectors.lte3.md) |  |
|  [lte4](./vectors.lte4.md) |  |
|  [madd](./vectors.madd.md) |  |
|  [madd2](./vectors.madd2.md) |  |
|  [madd3](./vectors.madd3.md) |  |
|  [madd4](./vectors.madd4.md) |  |
|  [maddN](./vectors.maddn.md) |  |
|  [maddN2](./vectors.maddn2.md) |  |
|  [maddN3](./vectors.maddn3.md) |  |
|  [maddN4](./vectors.maddn4.md) |  |
|  [maddNS2](./vectors.maddns2.md) |  |
|  [maddNS3](./vectors.maddns3.md) |  |
|  [maddNS4](./vectors.maddns4.md) |  |
|  [maddS2](./vectors.madds2.md) |  |
|  [maddS3](./vectors.madds3.md) |  |
|  [maddS4](./vectors.madds4.md) |  |
|  [mag](./vectors.mag.md) |  |
|  [magS2](./vectors.mags2.md) |  |
|  [magS3](./vectors.mags3.md) |  |
|  [magS4](./vectors.mags4.md) |  |
|  [magSq](./vectors.magsq.md) |  |
|  [magSq2](./vectors.magsq2.md) |  |
|  [magSq3](./vectors.magsq3.md) |  |
|  [magSq4](./vectors.magsq4.md) |  |
|  [magSqS2](./vectors.magsqs2.md) |  |
|  [magSqS3](./vectors.magsqs3.md) |  |
|  [magSqS4](./vectors.magsqs4.md) |  |
|  [major](./vectors.major.md) | Returns index of major component/axis in <code>v</code>, i.e. where <code>&#124;v[i]&#124;</code> is the largest. |
|  [major2](./vectors.major2.md) |  |
|  [major3](./vectors.major3.md) |  |
|  [major4](./vectors.major4.md) |  |
|  [mapBuffer](./vectors.mapbuffer.md) | Takes an <code>ArrayBuffer</code> and creates a number of typed array vector views of <code>type</code> with given <code>size</code> (number of elements per vector) and spacing. <code>byteOffset</code> defines the start offset for the first vector and <code>byteStride</code> the number of bytes between resulting vectors (defaults to <code>size * SIZEOF[type]</code>). It's user's responsibility to ensure these two values are compatible with the chosen array type (i.e. for <code>Type.F32</code>, these MUST be multiples of 4). |
|  [mapStridedBuffer](./vectors.mapstridedbuffer.md) |  |
|  [mapV](./vectors.mapv.md) | Like [mapVV](./vectors.mapvv.md)<!-- -->, but for [VecOpV](./vectors.vecopv.md) type ops and hence only using single input.
```
// 4x 2D vectors in SOA layout
// i.e. [x1, x2, x3, x4, y1, y2, y3, y4]
buf = [1, 3, 5, 7, 2, 4, 6, 8];

// use `swapXY` to swizzle each vector and use AOS for output
res = mapV(swapXY, new Vec2(), new Vec2(buf, 0, 4), 4, 2, 1);
// [ 2, 1, 4, 3, 6, 5, 8, 7 ]

// unpack result for demonstration purposes
[...Vec2.iterator(res, 4)].map(v => [...v]);
// [ [ 2, 1 ], [ 4, 3 ], [ 6, 5 ], [ 8, 7 ] ]

```
 |
|  [mapVN](./vectors.mapvn.md) | Like [mapVV](./vectors.mapvv.md)<!-- -->, but for [VecOpVN](./vectors.vecopvn.md) type ops and hence using a single vector input buffer <code>a</code> and a scalar <code>n</code>. |
|  [mapVV](./vectors.mapvv.md) | Vec2/3/4 view based buffer transformation for [VecOpVV](./vectors.vecopvv.md) type ops and supporting arbitrary component and element layouts of all input and output buffers. The given pre-initialized vectors MUST be separate instances, are used as sliding cursors / views of their respective backing buffers and will be modified as part of the transformation process (though the input buffers themselves are treated as immutable, unless <code>out</code> is configured to use one of the input buffers).<!-- -->In each iteration <code>op</code> is called via <code>op(out, a, b)</code>, followed by cursor updates to process the next vector view. No bounds checking is performed.<!-- -->This function returns <code>out</code>'s backing buffer.
```
// each input buffer contains 2 2D vectors, but using
// different strided data layouts
mapVV(
  // transformation function
  add,
  // init output buffer view
  new Vec2(),
  // wrap 1st input buffer & configure offset & component stride
  new Vec2([1,0,2,0,0,0,0,0,3,0,4,0,0,0,0,0], 0, 2),
  // wrap 2nd input buffer
  new Vec2([0,10,0,0,20,0,0,30,0,0,40], 1, 3),
  2, // num vectors
  2, // output element stride
  8, // input #1 element stride
  6  // input #2 element stride
);
// [ 11, 22, 33, 44 ]

```
Alternatively, <code>Vec2/3/4.iterator()</code> combined with transducers can be used to achieve the same (and more flexible) transformations, but will incur more intermediate object allocations. <code>mapV*()</code> functions only use (and mutate) the provided vector instances and do not allocate any further objects.
```
// output buffer
const out = new Array(4);

tx.run(
  tx.map(([o, a, b]) => add(o, a, b)),
  tx.zip(
     Vec2.iterator(out, 2),
     Vec2.iterator([1,0,2,0,0,0,0,0,3,0,4,0,0,0,0,0], 2, 0, 2, 8),
     Vec2.iterator([0,10,0,0,20,0,0,30,0,0,40], 2, 1, 3, 6),
  )
);

out
// [ 11, 22, 33, 44 ]

```
 |
|  [mapVVN](./vectors.mapvvn.md) | Like [mapVV](./vectors.mapvv.md)<!-- -->, but for [VecOpVVN](./vectors.vecopvvn.md) type ops and hence using two vector input buffers <code>a</code>, <code>b</code> and a scalar <code>n</code>. |
|  [mapVVV](./vectors.mapvvv.md) | Like [mapVV](./vectors.mapvv.md)<!-- -->, but for [VecOpVVV](./vectors.vecopvvv.md) type ops and hence using three vector input buffers <code>a</code>, <code>b</code>, <code>c</code>. |
|  [MATH\_N](./vectors.math_n.md) |  |
|  [MATH](./vectors.math.md) |  |
|  [MATH2\_N](./vectors.math2_n.md) |  |
|  [MATH2](./vectors.math2.md) |  |
|  [MATH2A\_N](./vectors.math2a_n.md) |  |
|  [max](./vectors.max.md) |  |
|  [max2](./vectors.max2.md) |  |
|  [MAX2](./vectors.max2.md) |  |
|  [max3](./vectors.max3.md) |  |
|  [MAX3](./vectors.max3.md) |  |
|  [max4](./vectors.max4.md) |  |
|  [MAX4](./vectors.max4.md) |  |
|  [min](./vectors.min.md) |  |
|  [min2](./vectors.min2.md) |  |
|  [MIN2](./vectors.min2.md) |  |
|  [min3](./vectors.min3.md) |  |
|  [MIN3](./vectors.min3.md) |  |
|  [min4](./vectors.min4.md) |  |
|  [MIN4](./vectors.min4.md) |  |
|  [minor](./vectors.minor.md) | Returns index of minor component/axis in <code>v</code>, i.e. where <code>&#124;v[i]&#124;</code> is the smallest. |
|  [minor2](./vectors.minor2.md) |  |
|  [minor3](./vectors.minor3.md) |  |
|  [minor4](./vectors.minor4.md) |  |
|  [MIX\_N](./vectors.mix_n.md) |  |
|  [mix](./vectors.mix.md) |  |
|  [MIX](./vectors.mix.md) |  |
|  [mix2](./vectors.mix2.md) |  |
|  [mix3](./vectors.mix3.md) |  |
|  [mix4](./vectors.mix4.md) |  |
|  [mixBilinear](./vectors.mixbilinear.md) |  |
|  [mixBilinear2](./vectors.mixbilinear2.md) |  |
|  [mixBilinear3](./vectors.mixbilinear3.md) |  |
|  [mixBilinear4](./vectors.mixbilinear4.md) |  |
|  [mixCubic](./vectors.mixcubic.md) |  |
|  [mixCubicHermite](./vectors.mixcubichermite.md) | Vector version of thi.ng/math [mixCubicHermite](./vectors.mixcubichermite.md)<!-- -->. |
|  [mixHermiteCardinal](./vectors.mixhermitecardinal.md) | Convenience version of [mixCubicHermite](./vectors.mixcubichermite.md)<!-- -->, using 4 input points and [tangentCardinal](./vectors.tangentcardinal.md) to compute the tangents for points <code>b</code> and <code>c</code> (with optional <code>scale</code>, default 0.5). Interpolated result point is that of <code>b</code> and <code>c</code>, with <code>a</code> and <code>d</code> only being used for tangent calculations.<!-- -->If <code>out</code> is null, stores result in <code>b</code>. |
|  [mixHermiteDiff3](./vectors.mixhermitediff3.md) | Convenience version of [mixCubicHermite](./vectors.mixcubichermite.md)<!-- -->, using 4 input points and [tangentDiff3](./vectors.tangentdiff3.md) to compute the tangents for points <code>b</code> and <code>c</code>. Interpolated result point is that of <code>b</code> and <code>c</code>, with <code>a</code> and <code>d</code> only being used for tangent calculations.<!-- -->If <code>out</code> is null, stores result in <code>b</code>. |
|  [mixN](./vectors.mixn.md) |  |
|  [mixN2](./vectors.mixn2.md) |  |
|  [mixN3](./vectors.mixn3.md) |  |
|  [mixN4](./vectors.mixn4.md) |  |
|  [mixNS2](./vectors.mixns2.md) |  |
|  [mixNS3](./vectors.mixns3.md) |  |
|  [mixNS4](./vectors.mixns4.md) |  |
|  [mixQuadratic](./vectors.mixquadratic.md) |  |
|  [mixS2](./vectors.mixs2.md) |  |
|  [mixS3](./vectors.mixs3.md) |  |
|  [mixS4](./vectors.mixs4.md) |  |
|  [mod](./vectors.mod.md) |  |
|  [mod2](./vectors.mod2.md) |  |
|  [mod3](./vectors.mod3.md) |  |
|  [mod4](./vectors.mod4.md) |  |
|  [modN](./vectors.modn.md) |  |
|  [modN2](./vectors.modn2.md) |  |
|  [modN3](./vectors.modn3.md) |  |
|  [modN4](./vectors.modn4.md) |  |
|  [msub](./vectors.msub.md) |  |
|  [msub2](./vectors.msub2.md) |  |
|  [msub3](./vectors.msub3.md) |  |
|  [msub4](./vectors.msub4.md) |  |
|  [msubN](./vectors.msubn.md) |  |
|  [msubN2](./vectors.msubn2.md) |  |
|  [msubN3](./vectors.msubn3.md) |  |
|  [msubN4](./vectors.msubn4.md) |  |
|  [msubNS2](./vectors.msubns2.md) |  |
|  [msubNS3](./vectors.msubns3.md) |  |
|  [msubNS4](./vectors.msubns4.md) |  |
|  [msubS2](./vectors.msubs2.md) |  |
|  [msubS3](./vectors.msubs3.md) |  |
|  [msubS4](./vectors.msubs4.md) |  |
|  [mul](./vectors.mul.md) |  |
|  [mul2](./vectors.mul2.md) |  |
|  [mul3](./vectors.mul3.md) |  |
|  [mul4](./vectors.mul4.md) |  |
|  [mulI](./vectors.muli.md) |  |
|  [mulI2](./vectors.muli2.md) |  |
|  [mulI3](./vectors.muli3.md) |  |
|  [mulI4](./vectors.muli4.md) |  |
|  [mulN](./vectors.muln.md) |  |
|  [mulN2](./vectors.muln2.md) |  |
|  [mulN3](./vectors.muln3.md) |  |
|  [mulN4](./vectors.muln4.md) |  |
|  [mulNI](./vectors.mulni.md) |  |
|  [mulNI2](./vectors.mulni2.md) |  |
|  [mulNI3](./vectors.mulni3.md) |  |
|  [mulNI4](./vectors.mulni4.md) |  |
|  [mulNS2](./vectors.mulns2.md) |  |
|  [mulNS3](./vectors.mulns3.md) |  |
|  [mulNS4](./vectors.mulns4.md) |  |
|  [mulNU](./vectors.mulnu.md) |  |
|  [mulNU2](./vectors.mulnu2.md) |  |
|  [mulNU3](./vectors.mulnu3.md) |  |
|  [mulNU4](./vectors.mulnu4.md) |  |
|  [mulS2](./vectors.muls2.md) |  |
|  [mulS3](./vectors.muls3.md) |  |
|  [mulS4](./vectors.muls4.md) |  |
|  [mulU](./vectors.mulu.md) |  |
|  [mulU2](./vectors.mulu2.md) |  |
|  [mulU3](./vectors.mulu3.md) |  |
|  [mulU4](./vectors.mulu4.md) |  |
|  [neg](./vectors.neg.md) |  |
|  [neq](./vectors.neq.md) |  |
|  [neq2](./vectors.neq2.md) |  |
|  [neq3](./vectors.neq3.md) |  |
|  [neq4](./vectors.neq4.md) |  |
|  [NEW\_OUT](./vectors.new_out.md) |  |
|  [normalCCW](./vectors.normalccw.md) | Computes 2D normal by rotating direction vector <code>a</code> -<!-- -->&gt; <code>b</code>, 90 deg counterclockwise, normalized to length <code>n</code> (default: 1). If <code>out</code> is null, creates new vector. |
|  [normalCW](./vectors.normalcw.md) | Computes 2D normal by rotating direction vector <code>a</code> -<!-- -->&gt; <code>b</code>, 90 deg clockwise, normalized to length <code>n</code> (default: 1). If <code>out</code> is null, creates new vector. |
|  [normalize](./vectors.normalize.md) | Normalizes vector to given (optional) length (default: 1). If <code>out</code> is null, modifies <code>v</code> in place. |
|  [normalizeS2](./vectors.normalizes2.md) | Normalizes vector to given (optional) length (default: 1). If <code>out</code> is null, modifies <code>v</code> in place. |
|  [normalizeS3](./vectors.normalizes3.md) | Normalizes vector to given (optional) length (default: 1). If <code>out</code> is null, modifies <code>v</code> in place. |
|  [normalizeS4](./vectors.normalizes4.md) | Normalizes vector to given (optional) length (default: 1). If <code>out</code> is null, modifies <code>v</code> in place. |
|  [one](./vectors.one.md) |  |
|  [ONE2](./vectors.one2.md) |  |
|  [ONE3](./vectors.one3.md) |  |
|  [ONE4](./vectors.one4.md) |  |
|  [ones](./vectors.ones.md) |  |
|  [orthoNormal3](./vectors.orthonormal3.md) | Produces a vector which is perpendicular/normal to the plane spanned by given 3 input vectors. If <code>normalize</code> is true (default), the result vector will be normalized. |
|  [perpendicularCCW](./vectors.perpendicularccw.md) | 2D only. Produces a perpendicular vector to <code>v</code>, i.e. <code>[-y,x]</code>. Assumes positive Y-up. |
|  [perpendicularCW](./vectors.perpendicularcw.md) | 2D only. Produces a clockwise perpendicular vector to <code>v</code>, i.e. <code>[y,-x]</code>. Assumes positive Y-up. |
|  [polar](./vectors.polar.md) | Converts cartesian vector <code>v</code> to polar coordinates. See [cartesian](./vectors.cartesian.md) for reverse operation. If <code>out</code> is null, modifies <code>v</code> in place. |
|  [polar2](./vectors.polar2.md) | Converts 2D cartesian vector <code>v</code> to polar coordinates, i.e. <code>[r,θ]</code> (angle in radians). See [cartesian](./vectors.cartesian.md) for reverse operation. If <code>out</code> is null, modifies <code>v</code> in place. |
|  [polar3](./vectors.polar3.md) | Converts 3D cartesian vector <code>v</code> to spherical coordinates, i.e. <code>[r,θ,ϕ]</code> (angles in radians). See [cartesian](./vectors.cartesian.md) for reverse operation. If <code>out</code> is null, modifies <code>v</code> in place. |
|  [pow](./vectors.pow.md) |  |
|  [pow2](./vectors.pow2.md) |  |
|  [pow3](./vectors.pow3.md) |  |
|  [pow4](./vectors.pow4.md) |  |
|  [powN](./vectors.pown.md) |  |
|  [powN2](./vectors.pown2.md) |  |
|  [powN3](./vectors.pown3.md) |  |
|  [powN4](./vectors.pown4.md) |  |
|  [project](./vectors.project.md) | Returns vector projection of <code>v</code> onto <code>dir</code>.[https://en.wikipedia.org/wiki/Vector\_projection](https://en.wikipedia.org/wiki/Vector_projection) |
|  [radians](./vectors.radians.md) |  |
|  [radians2](./vectors.radians2.md) |  |
|  [radians3](./vectors.radians3.md) |  |
|  [radians4](./vectors.radians4.md) |  |
|  [randMinMax](./vectors.randminmax.md) |  |
|  [randMinMax2](./vectors.randminmax2.md) |  |
|  [randMinMax3](./vectors.randminmax3.md) |  |
|  [randMinMax4](./vectors.randminmax4.md) |  |
|  [randMinMaxS2](./vectors.randminmaxs2.md) |  |
|  [randMinMaxS3](./vectors.randminmaxs3.md) |  |
|  [randMinMaxS4](./vectors.randminmaxs4.md) |  |
|  [randNorm](./vectors.randnorm.md) | Sets <code>v</code> to random vector, normalized to length <code>n</code> (default: 1). If no <code>rnd</code> instance is given, uses [SYSTEM](./random.system.md)<!-- -->, i.e. <code>Math.random</code>. |
|  [randNormS2](./vectors.randnorms2.md) | Sets <code>v</code> to random vector, normalized to length <code>n</code> (default: 1). If no <code>rnd</code> instance is given, uses [SYSTEM](./random.system.md)<!-- -->, i.e. <code>Math.random</code>. |
|  [randNormS3](./vectors.randnorms3.md) |  |
|  [randNormS4](./vectors.randnorms4.md) |  |
|  [random](./vectors.random.md) |  |
|  [random2](./vectors.random2.md) |  |
|  [random3](./vectors.random3.md) |  |
|  [random4](./vectors.random4.md) |  |
|  [randomS2](./vectors.randoms2.md) |  |
|  [randomS3](./vectors.randoms3.md) |  |
|  [randomS4](./vectors.randoms4.md) |  |
|  [reflect](./vectors.reflect.md) |  |
|  [refract](./vectors.refract.md) |  |
|  [rotate](./vectors.rotate.md) | Alias for [rotateZ](./vectors.rotatez.md) (e.g. for 2D use cases) |
|  [rotateAroundAxis3](./vectors.rotatearoundaxis3.md) |  |
|  [rotateAroundPoint2](./vectors.rotatearoundpoint2.md) |  |
|  [rotateS2](./vectors.rotates2.md) |  |
|  [rotateX](./vectors.rotatex.md) |  |
|  [rotateXS3](./vectors.rotatexs3.md) |  |
|  [rotateY](./vectors.rotatey.md) |  |
|  [rotateYS3](./vectors.rotateys3.md) |  |
|  [rotateZ](./vectors.rotatez.md) |  |
|  [rotateZS3](./vectors.rotatezs3.md) |  |
|  [round](./vectors.round.md) |  |
|  [round2](./vectors.round2.md) |  |
|  [round3](./vectors.round3.md) |  |
|  [round4](./vectors.round4.md) |  |
|  [rshiftI](./vectors.rshifti.md) |  |
|  [rshiftI2](./vectors.rshifti2.md) |  |
|  [rshiftI3](./vectors.rshifti3.md) |  |
|  [rshiftI4](./vectors.rshifti4.md) |  |
|  [rshiftNI](./vectors.rshiftni.md) |  |
|  [rshiftNI2](./vectors.rshiftni2.md) |  |
|  [rshiftNI3](./vectors.rshiftni3.md) |  |
|  [rshiftNI4](./vectors.rshiftni4.md) |  |
|  [rshiftNU](./vectors.rshiftnu.md) |  |
|  [rshiftNU2](./vectors.rshiftnu2.md) |  |
|  [rshiftNU3](./vectors.rshiftnu3.md) |  |
|  [rshiftNU4](./vectors.rshiftnu4.md) |  |
|  [rshiftU](./vectors.rshiftu.md) |  |
|  [rshiftU2](./vectors.rshiftu2.md) |  |
|  [rshiftU3](./vectors.rshiftu3.md) |  |
|  [rshiftU4](./vectors.rshiftu4.md) |  |
|  [SARGS\_V](./vectors.sargs_v.md) |  |
|  [SARGS\_VV](./vectors.sargs_vv.md) |  |
|  [SARGS\_VVV](./vectors.sargs_vvv.md) |  |
|  [SET\_N](./vectors.set_n.md) |  |
|  [set](./vectors.set.md) |  |
|  [SET](./vectors.set.md) |  |
|  [set2](./vectors.set2.md) |  |
|  [set3](./vectors.set3.md) |  |
|  [set4](./vectors.set4.md) |  |
|  [setC](./vectors.setc.md) |  |
|  [setC2](./vectors.setc2.md) |  |
|  [setC3](./vectors.setc3.md) |  |
|  [setC4](./vectors.setc4.md) |  |
|  [setC6](./vectors.setc6.md) |  |
|  [setCS2](./vectors.setcs2.md) |  |
|  [setCS3](./vectors.setcs3.md) |  |
|  [setCS4](./vectors.setcs4.md) |  |
|  [setN](./vectors.setn.md) |  |
|  [setN2](./vectors.setn2.md) |  |
|  [setN3](./vectors.setn3.md) |  |
|  [setN4](./vectors.setn4.md) |  |
|  [setNS2](./vectors.setns2.md) |  |
|  [setNS3](./vectors.setns3.md) |  |
|  [setNS4](./vectors.setns4.md) |  |
|  [setS](./vectors.sets.md) |  |
|  [setS2](./vectors.sets2.md) |  |
|  [setS3](./vectors.sets3.md) |  |
|  [setS4](./vectors.sets4.md) |  |
|  [setSwizzle1](./vectors.setswizzle1.md) | Sets <code>out[a] = n</code>, returns <code>out</code>. |
|  [setSwizzle2](./vectors.setswizzle2.md) | Sets <code>out[a] = v.x, out[b] = v.y</code>, returns <code>out</code>. |
|  [setSwizzle3](./vectors.setswizzle3.md) | Sets <code>out[a] = v.x, out[b] = v.y, out[c] = v.z</code>, returns <code>out</code>. |
|  [setSwizzle4](./vectors.setswizzle4.md) | Sets <code>out[a] = v.x, out[b] = v.y, out[c] = v.z, out[d]=v.w</code>, returns <code>out</code>. |
|  [setVN3](./vectors.setvn3.md) | Sets <code>out</code> to <code>[a.x, a.y, n]</code> |
|  [setVN4](./vectors.setvn4.md) | Sets <code>out</code> to <code>[a.x, a.y, a.z, n]</code> |
|  [setVV16](./vectors.setvv16.md) | Sets <code>out</code> to:
```
[a.x, a.y, a.z, a.w, b.x, b.y, b.z, b.w,
 c.x, c.y, c.z, c.w, d.x, d.y, d.z, d.w]

```
 |
|  [setVV4](./vectors.setvv4.md) | Sets <code>out</code> to <code>[a.x, a.y, b.x, b.y]</code> |
|  [setVV6](./vectors.setvv6.md) | Sets <code>out</code> to <code>[a.x, a.y, b.x, b.y, c.x, c.y]</code> |
|  [setVV9](./vectors.setvv9.md) | Sets <code>out</code> to: <code>[a.x, a.y, a.z, b.x, b.y, b.z, c.x, c.y, c.z]</code> |
|  [sign](./vectors.sign.md) |  |
|  [sign2](./vectors.sign2.md) |  |
|  [sign3](./vectors.sign3.md) |  |
|  [sign4](./vectors.sign4.md) |  |
|  [SIGNED\_N](./vectors.signed_n.md) |  |
|  [SIGNED](./vectors.signed.md) |  |
|  [signedArea2](./vectors.signedarea2.md) | Returns area \* 2 of the 2D triangle defined by the input vectors. This is a useful classifier for many geometry processing tasks. In addition to the triangle area, the result can also be interpreted as follows:<!-- -->- <code>&gt; 0</code>: points are ordered counterclockwise - <code>&lt; 0</code>: points are ordered clockwise - <code>0</code>: points are co-linear<!-- -->Same as: <code>cross2(sub2([], b, a), sub2([], c, a))</code>- [corner2](./vectors.corner2.md) - [clockwise2](./vectors.clockwise2.md) - [cross2](./vectors.cross2.md) |
|  [signedAreaC2](./vectors.signedareac2.md) | Same as [signedArea2](./vectors.signedarea2.md)<!-- -->, but expects individual vector component args, instead of vectors. |
|  [sin](./vectors.sin.md) |  |
|  [sin2](./vectors.sin2.md) |  |
|  [sin3](./vectors.sin3.md) |  |
|  [sin4](./vectors.sin4.md) |  |
|  [sinh](./vectors.sinh.md) |  |
|  [sinh2](./vectors.sinh2.md) |  |
|  [sinh3](./vectors.sinh3.md) |  |
|  [sinh4](./vectors.sinh4.md) |  |
|  [smoothStep](./vectors.smoothstep.md) |  |
|  [smoothStep2](./vectors.smoothstep2.md) |  |
|  [smoothStep3](./vectors.smoothstep3.md) |  |
|  [smoothStep4](./vectors.smoothstep4.md) |  |
|  [some](./vectors.some.md) | Returns returns true if at least one vector component in <code>v</code> is truthy. |
|  [some2](./vectors.some2.md) |  |
|  [some3](./vectors.some3.md) |  |
|  [some4](./vectors.some4.md) |  |
|  [sqrt](./vectors.sqrt.md) |  |
|  [sqrt2](./vectors.sqrt2.md) |  |
|  [sqrt3](./vectors.sqrt3.md) |  |
|  [sqrt4](./vectors.sqrt4.md) |  |
|  [step](./vectors.step.md) |  |
|  [step2](./vectors.step2.md) |  |
|  [step3](./vectors.step3.md) |  |
|  [step4](./vectors.step4.md) |  |
|  [sub](./vectors.sub.md) |  |
|  [sub2](./vectors.sub2.md) |  |
|  [sub3](./vectors.sub3.md) |  |
|  [sub4](./vectors.sub4.md) |  |
|  [subI](./vectors.subi.md) |  |
|  [subI2](./vectors.subi2.md) |  |
|  [subI3](./vectors.subi3.md) |  |
|  [subI4](./vectors.subi4.md) |  |
|  [subm](./vectors.subm.md) |  |
|  [subm2](./vectors.subm2.md) |  |
|  [subm3](./vectors.subm3.md) |  |
|  [subm4](./vectors.subm4.md) |  |
|  [submN](./vectors.submn.md) |  |
|  [submN2](./vectors.submn2.md) |  |
|  [submN3](./vectors.submn3.md) |  |
|  [submN4](./vectors.submn4.md) |  |
|  [submNS2](./vectors.submns2.md) |  |
|  [submNS3](./vectors.submns3.md) |  |
|  [submNS4](./vectors.submns4.md) |  |
|  [submS2](./vectors.subms2.md) |  |
|  [submS3](./vectors.subms3.md) |  |
|  [submS4](./vectors.subms4.md) |  |
|  [subN](./vectors.subn.md) |  |
|  [subN2](./vectors.subn2.md) |  |
|  [subN3](./vectors.subn3.md) |  |
|  [subN4](./vectors.subn4.md) |  |
|  [subNI](./vectors.subni.md) |  |
|  [subNI2](./vectors.subni2.md) |  |
|  [subNI3](./vectors.subni3.md) |  |
|  [subNI4](./vectors.subni4.md) |  |
|  [subNS2](./vectors.subns2.md) |  |
|  [subNS3](./vectors.subns3.md) |  |
|  [subNS4](./vectors.subns4.md) |  |
|  [subNU](./vectors.subnu.md) |  |
|  [subNU2](./vectors.subnu2.md) |  |
|  [subNU3](./vectors.subnu3.md) |  |
|  [subNU4](./vectors.subnu4.md) |  |
|  [subS2](./vectors.subs2.md) |  |
|  [subS3](./vectors.subs3.md) |  |
|  [subS4](./vectors.subs4.md) |  |
|  [subU](./vectors.subu.md) |  |
|  [subU2](./vectors.subu2.md) |  |
|  [subU3](./vectors.subu3.md) |  |
|  [subU4](./vectors.subu4.md) |  |
|  [sum](./vectors.sum.md) | Returns component sum of vector <code>v</code>. |
|  [sum2](./vectors.sum2.md) |  |
|  [sum3](./vectors.sum3.md) |  |
|  [sum4](./vectors.sum4.md) |  |
|  [swapXY](./vectors.swapxy.md) |  |
|  [swapXZ](./vectors.swapxz.md) |  |
|  [swapYZ](./vectors.swapyz.md) |  |
|  [swizzle2](./vectors.swizzle2.md) | Places a re-ordered 2D version of vector <code>a</code> into <code>out</code>. The given coord indices must be valid for <code>a</code>. No bounds checking. |
|  [swizzle3](./vectors.swizzle3.md) | Places a re-ordered 3D version of vector <code>a</code> into <code>out</code>. The given coord indices must be valid for <code>a</code>. No bounds checking. |
|  [swizzle4](./vectors.swizzle4.md) | Places a re-ordered 4D version of vector <code>a</code> into <code>out</code>. The given coord indices must be valid for <code>a</code>. No bounds checking. |
|  [tan](./vectors.tan.md) |  |
|  [tan2](./vectors.tan2.md) |  |
|  [tan3](./vectors.tan3.md) |  |
|  [tan4](./vectors.tan4.md) |  |
|  [tangentCardinal](./vectors.tangentcardinal.md) | Vector version of thi.ng/math [tangentCardinal](./vectors.tangentcardinal.md)<!-- -->. |
|  [tangentDiff3](./vectors.tangentdiff3.md) | Vector version of thi.ng/math [tangentDiff3](./vectors.tangentdiff3.md)<!-- -->. |
|  [tanh](./vectors.tanh.md) |  |
|  [tanh2](./vectors.tanh2.md) |  |
|  [tanh3](./vectors.tanh3.md) |  |
|  [tanh4](./vectors.tanh4.md) |  |
|  [trunc](./vectors.trunc.md) |  |
|  [trunc2](./vectors.trunc2.md) |  |
|  [trunc3](./vectors.trunc3.md) |  |
|  [trunc4](./vectors.trunc4.md) |  |
|  [UNSIGNED\_N](./vectors.unsigned_n.md) |  |
|  [UNSIGNED](./vectors.unsigned.md) |  |
|  [vec2](./vectors.vec2.md) |  |
|  [vec2n](./vectors.vec2n.md) |  |
|  [vec3](./vectors.vec3.md) |  |
|  [vec3n](./vectors.vec3n.md) |  |
|  [vec4](./vectors.vec4.md) |  |
|  [vec4n](./vectors.vec4n.md) |  |
|  [vecOf](./vectors.vecof.md) | Returns new vector of <code>size</code> with all components set to <code>n</code>. |
|  [vop](./vectors.vop.md) | Specialized / optimized version of [@thi.ng/defmulti](./defmulti.md) for vector operations. Uses simplified logic to dispatch on length (vector size) of <code>dispatch</code> argument. |
|  [W4](./vectors.w4.md) |  |
|  [wrap](./vectors.wrap.md) |  |
|  [wrap2](./vectors.wrap2.md) |  |
|  [wrap3](./vectors.wrap3.md) |  |
|  [wrap4](./vectors.wrap4.md) |  |
|  [X2](./vectors.x2.md) |  |
|  [X3](./vectors.x3.md) |  |
|  [X4](./vectors.x4.md) |  |
|  [Y2](./vectors.y2.md) |  |
|  [Y3](./vectors.y3.md) |  |
|  [Y4](./vectors.y4.md) |  |
|  [Z3](./vectors.z3.md) |  |
|  [Z4](./vectors.z4.md) |  |
|  [zero](./vectors.zero.md) |  |
|  [ZERO2](./vectors.zero2.md) |  |
|  [ZERO3](./vectors.zero3.md) |  |
|  [ZERO4](./vectors.zero4.md) |  |
|  [zeroes](./vectors.zeroes.md) |  |

## Type Aliases

|  Type Alias | Description |
|  --- | --- |
|  [BVec2Like](./vectors.bvec2like.md) |  |
|  [BVec3Like](./vectors.bvec3like.md) |  |
|  [BVec4Like](./vectors.bvec4like.md) |  |
|  [BVecOpRoV](./vectors.bvecoprov.md) |  |
|  [BVecOpV](./vectors.bvecopv.md) |  |
|  [BVecOpVN](./vectors.bvecopvn.md) |  |
|  [BVecOpVV](./vectors.bvecopvv.md) |  |
|  [CompareOp](./vectors.compareop.md) |  |
|  [ReadonlyBVec](./vectors.readonlybvec.md) |  |
|  [ReadonlyVec](./vectors.readonlyvec.md) |  |
|  [Template](./vectors.template.md) |  |
|  [ToBVecOpV](./vectors.tobvecopv.md) |  |
|  [Vec2Like](./vectors.vec2like.md) |  |
|  [Vec3Like](./vectors.vec3like.md) |  |
|  [Vec4Like](./vectors.vec4like.md) |  |
|  [VecOpN](./vectors.vecopn.md) |  |
|  [VecOpNNO](./vectors.vecopnno.md) |  |
|  [VecOpOO](./vectors.vecopoo.md) |  |
|  [VecOpOOO](./vectors.vecopooo.md) |  |
|  [VecOpRoV](./vectors.vecoprov.md) |  |
|  [VecOpRoVV](./vectors.vecoprovv.md) |  |
|  [VecOpRoVVO](./vectors.vecoprovvo.md) |  |
|  [VecOpSOO](./vectors.vecopsoo.md) |  |
|  [VecOpSOOO](./vectors.vecopsooo.md) |  |
|  [VecOpSRoV](./vectors.vecopsrov.md) |  |
|  [VecOpSRoVV](./vectors.vecopsrovv.md) |  |
|  [VecOpSV](./vectors.vecopsv.md) |  |
|  [VecOpSVN](./vectors.vecopsvn.md) |  |
|  [VecOpSVNV](./vectors.vecopsvnv.md) |  |
|  [VecOpSVO](./vectors.vecopsvo.md) |  |
|  [VecOpSVV](./vectors.vecopsvv.md) |  |
|  [VecOpSVVN](./vectors.vecopsvvn.md) |  |
|  [VecOpSVVV](./vectors.vecopsvvv.md) |  |
|  [VecOpV](./vectors.vecopv.md) |  |
|  [VecOpVN](./vectors.vecopvn.md) |  |
|  [VecOpVNN](./vectors.vecopvnn.md) |  |
|  [VecOpVNV](./vectors.vecopvnv.md) |  |
|  [VecOpVO](./vectors.vecopvo.md) |  |
|  [VecOpVV](./vectors.vecopvv.md) |  |
|  [VecOpVVN](./vectors.vecopvvn.md) |  |
|  [VecOpVVV](./vectors.vecopvvv.md) |  |
|  [VecOpVVVVNN](./vectors.vecopvvvvnn.md) |  |
|  [VecPair](./vectors.vecpair.md) |  |

