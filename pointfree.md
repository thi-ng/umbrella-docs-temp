<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/pointfree](./pointfree.md)

## pointfree package

## Interfaces

|  Interface | Description |
|  --- | --- |
|  [StackContext](./pointfree.stackcontext.md) |  |

## Variables

|  Variable | Description |
|  --- | --- |
|  [$](./pointfree._.md) |  |
|  [$n](./pointfree._n.md) |  |
|  [$stackFn](./pointfree._stackfn.md) |  |
|  [$try](./pointfree._try.md) | Expects a body and error handler quotation on stack. Executes body within an implicit <code>try .. catch</code> and if an error was thrown pushes it on stack and executes error quotation.<!-- -->( body catch -- ? ) |
|  [add](./pointfree.add.md) | ( x y -- x+y ) |
|  [and](./pointfree.and.md) | ( x y -- x&amp;&amp;y ) |
|  [at](./pointfree.at.md) | Reads key/index from object/array.<!-- -->( obj k -- obj\[k\] ) |
|  [atan2](./pointfree.atan2.md) | ( x y -- atan2(y,x) ) |
|  [bi](./pointfree.bi.md) | First applies <code>p</code> to the value <code>x</code>, then applies <code>q</code> to the same value.<!-- -->( x p q -- px qx ) |
|  [bi2](./pointfree.bi2.md) | First applies <code>p</code> to the two input values <code>x y</code>, then applies <code>q</code> to the same values.<!-- -->( x y p q -- pxy qxy ) |
|  [bi3](./pointfree.bi3.md) | First applies <code>p</code> to the three input values <code>x y z</code>, then applies <code>q</code> to the same values.<!-- -->( x y z p q -- pxyz qxyz ) |
|  [bia](./pointfree.bia.md) | Applies the quotation <code>q</code> to <code>x</code>, then to <code>y</code>.<!-- -->( x y q -- qx qy ) |
|  [bia2](./pointfree.bia2.md) | Applies the quotation <code>q</code> to <code>x y</code>, then to <code>z w</code>.<!-- -->( x y z w q -- qxy qzw ) |
|  [bindkeys](./pointfree.bindkeys.md) | Takes an array of keys and target object, then pops &amp; binds deeper stack values to respective keys in object. Pushes result object back on stack at the end. Throws error if there're less stack values than keys in given array. |
|  [bis](./pointfree.bis.md) | Applies <code>p</code> to <code>x</code>, then applies <code>q</code> to <code>y</code>.<!-- -->( x y p q -- px qy ) |
|  [bis2](./pointfree.bis2.md) | Applies <code>p</code> to <code>a b</code>, then applies <code>q</code> to <code>c d</code>.<!-- -->( a b c d p q -- pab qcd ) |
|  [bitand](./pointfree.bitand.md) | ( x y -- x&amp;y ) |
|  [bitnot](./pointfree.bitnot.md) | ( x -- \~x ) |
|  [bitor](./pointfree.bitor.md) | ( x y -- x\|y ) |
|  [bitxor](./pointfree.bitxor.md) | ( x y -- x^y ) |
|  [both](./pointfree.both.md) | Applies <code>q</code> individually to both input vals <code>x y</code> and combines results with <code>and</code>. The final result will be true if both interim results were truthy.<!-- -->( x y q -- qx &amp;&amp; qy ) |
|  [cases](./pointfree.cases.md) | Higher order word. Takes an object of stack programs with keys in the object being used to check for equality with TOS. If a match is found, executes corresponding stack program. If a <code>default</code> key is specified and no other cases matched, run <code>default</code> program. In all other cases throws an error.<!-- -->Important: The default case has the original TOS re-added to the d-stack before execution. |
|  [casesq](./pointfree.casesq.md) |  |
|  [cat](./pointfree.cat.md) | Concatenates two arrays on d-stack:<!-- -->( arr1 arr2 -- arr ) |
|  [ceil](./pointfree.ceil.md) | ( x -- ceil(x) ) |
|  [collect](./pointfree.collect.md) | Pops TOS (a number) and then forms a tuple of the top <code>n</code> remaining values and pushes it as new TOS. The original collected stack values are removed from d-stack.<!-- -->( ... n \-\-\- ... \[...\] ) |
|  [cond](./pointfree.cond.md) | Higher order word. Takes two stack programs: truthy and falsey branches, respectively. When executed, pops TOS and runs only one of the branches depending if TOS was truthy or not.<!-- -->Note: Unlike JS <code>if() {...} else {...}</code> constructs, the actual conditional is NOT part of this word.<!-- -->( bool -- ? ) |
|  [condq](./pointfree.condq.md) | Non-HOF version of [cond](./pointfree.cond.md)<!-- -->, expects <code>test</code> result and both branches on d-stack. Executes <code>thenq</code> word/quotation if <code>test</code> is truthy, else runs <code>elseq</code>.<!-- -->( test thenq elseq -- ? ) |
|  [copy](./pointfree.copy.md) | Replaces TOS with its shallow copy. MUST be an array or plain object.<!-- -->( x -- copy ) |
|  [cos](./pointfree.cos.md) | ( x -- cos(x) ) |
|  [cpdr](./pointfree.cpdr.md) |  |
|  [cpdr2](./pointfree.cpdr2.md) |  |
|  [cprd](./pointfree.cprd.md) |  |
|  [cprd2](./pointfree.cprd2.md) |  |
|  [ctx](./pointfree.ctx.md) | Creates a new StackContext tuple from given d-stack and/or environment only (the r-stack is always initialized empty). |
|  [dec](./pointfree.dec.md) | ( x -- x-1 ) |
|  [dip](./pointfree.dip.md) | Removes <code>x</code> from d-stack, calls <code>q</code> and restores <code>x</code> to the top of the d-stack after quotation is finished.<!-- -->( x q -- x )<!-- -->Same behavior as: <code>[swap, movdr, exec, movrd]</code>, only the current implementation doesn't use r-stack and stashes <code>x</code> off stack. |
|  [dip2](./pointfree.dip2.md) | Removes <code>x y</code> from d-stack, calls <code>q</code> and restores removed vals to the top of the d-stack after quotation is finished.<!-- -->( x y q -- x y ) |
|  [dip3](./pointfree.dip3.md) | Removes <code>x y z</code> from d-stack, calls <code>q</code> and restores removed vals to the top of the d-stack after quotation is finished.<!-- -->( x y z q -- x y z ) |
|  [dip4](./pointfree.dip4.md) | Removes <code>x y z w</code> from d-stack, calls <code>q</code> and restores removed vals to the top of the d-stack after quotation is finished.<!-- -->( x y z w q -- x y z w ) |
|  [div](./pointfree.div.md) | ( x y -- x/y ) |
|  [dotimes](./pointfree.dotimes.md) | Executes given <code>body</code> word/quotation <code>n</code> times. In each iteration pushes current counter on d-stack prior to executing body. |
|  [drop](./pointfree.drop.md) | Removes TOS from d-stack.<!-- -->( x -- ) |
|  [drop2](./pointfree.drop2.md) | Removes top 2 vals from d-stack.<!-- -->( x y -- ) |
|  [dropif](./pointfree.dropif.md) | If TOS is truthy then drop it:<!-- -->( x -- )<!-- -->Else, no effect:<!-- -->( x -- x ) |
|  [dsp](./pointfree.dsp.md) | Pushes current d-stack size on d-stack.<!-- -->( -- n ) |
|  [dup](./pointfree.dup.md) | Duplicates TOS on d-stack.<!-- -->( x -- x x ) |
|  [dup2](./pointfree.dup2.md) | Duplicates top 2 vals on d-stack.<!-- -->( x y -- x y x y ) |
|  [dup3](./pointfree.dup3.md) | Duplicates top 3 vals on d-stack.<!-- -->( x y -- x y x y ) |
|  [dupif](./pointfree.dupif.md) | If TOS is truthy then push copy of it on d-stack:<!-- -->( x -- x x )<!-- -->Else, no effect:<!-- -->( x -- x ) |
|  [either](./pointfree.either.md) | Applies <code>q</code> individually to both input vals <code>x y</code> and combines results with <code>or</code>. The final result will be true if at least one of the interim results was truthy.<!-- -->( x y q -- qx \|\| qy ) |
|  [eq](./pointfree.eq.md) | ( x y -- x===y ) |
|  [equiv](./pointfree.equiv.md) | ( x y -- equiv(x,y) ) |
|  [even](./pointfree.even.md) | ( x -- bool ) |
|  [exec](./pointfree.exec.md) | Executes TOS as stack function and places result back on d-stack. TOS MUST be a valid word or quotation.<!-- -->( x -- x() ) |
|  [execjs](./pointfree.execjs.md) | Expects TOS to be a quotation with a vanilla JS function as first element. Calls fn with all remaining items in quot as arguments and pushes result back on d-stack (even if fn returned <code>undefined</code>).<!-- -->( \[f ...\] -- f(...) ) |
|  [exp](./pointfree.exp.md) | ( x -- exp(x) ) |
|  [floor](./pointfree.floor.md) | ( x -- floor(x) ) |
|  [foldl](./pointfree.foldl.md) | Convenience wrapper for [mapl](./pointfree.mapl.md) to provide an alternative stack layout for reduction purposes:<!-- -->( arr q init -- reduction ) |
|  [fromjson](./pointfree.fromjson.md) | ( str -- obj ) |
|  [gt](./pointfree.gt.md) | ( x y -- x<!-- -->&gt;<!-- -->y ) |
|  [gteq](./pointfree.gteq.md) | ( x y -- x<!-- -->&gt;<!-- -->=y ) |
|  [hypot](./pointfree.hypot.md) | ( x y -- sqrt(x\*x+y\*y) ) |
|  [inc](./pointfree.inc.md) | ( x -- x+1 ) |
|  [invrot](./pointfree.invrot.md) | Rotates three topmost d-stack items upwards/to the right.<!-- -->( x y z -- z x y ) |
|  [ismatch](./pointfree.ismatch.md) | Takes a string and stringified regexp (w/o flags), returns true if regexp matches the string.<!-- -->( str re -- bool ) |
|  [isneg](./pointfree.isneg.md) | ( x -- x<!-- -->&lt;<!-- -->0 ) |
|  [isnull](./pointfree.isnull.md) | ( x -- x==null ) |
|  [ispos](./pointfree.ispos.md) | ( x -- x<!-- -->&gt;<!-- -->0 ) |
|  [iszero](./pointfree.iszero.md) | ( x -- x===0 ) |
|  [join](./pointfree.join.md) | Higher order helper word to convert a TOS tuple/array into a string using <code>Array.join()</code> with given <code>sep</code>arator. |
|  [keep](./pointfree.keep.md) | Calls a quotation with a value on the d-stack, restoring the value after quotation finished.<!-- -->( x q -- .. x ) |
|  [keep2](./pointfree.keep2.md) | Call a quotation with two values on the stack, restoring the values after quotation finished.<!-- -->( x y q -- .. x y ) |
|  [keep3](./pointfree.keep3.md) | Call a quotation with three values on the stack, restoring the values after quotation finished.<!-- -->( x y z q -- .. x y z ) |
|  [length](./pointfree.length.md) | Pushes length of TOS on d-stack.<!-- -->( x -- x.length ) |
|  [list](./pointfree.list.md) | Pushes a new empty array on the d-stack. While it's easily possible to use <code>[]</code> as part of a stack program, the <code>list</code> word is intended to be used as part of re-usuable [word](./pointfree.word.md) definitions to ensure a new array is being created for every single invocation of the word (else only a single instance is created due to the mutable nature of JS arrays).<!-- -->Compare:
```
// using array literal within word definition
foo = pf.word([ [], 1, pf.pushl ])
pf.runU(foo)
// [ 1 ]
pf.runU(foo)
// [ 1, 1 ] // wrong!

// using `list` instead
bar = pf.word([ pf.list, 1, pf.pushl ])
pf.runU(bar)
// [ 1 ]
pf.runU(bar)
// [ 1 ] // correct!

```
( -- \[\] ) |
|  [load](./pointfree.load.md) | Loads value for <code>key</code> from current env and pushes it on d-stack. Throws error if var doesn't exist.<!-- -->( key -- env\[key\] ) |
|  [loadkey](./pointfree.loadkey.md) | Higher order word. Similar to [load](./pointfree.load.md)<!-- -->, but always uses given preconfigured <code>key</code> instead of reading it from d-stack at runtime (also slightly faster). Throws error if var doesn't exist.<!-- -->( -- env\[key\] ) |
|  [log](./pointfree.log.md) | ( x -- log(x) ) |
|  [loop](./pointfree.loop.md) | Higher order word. Takes a <code>test</code> and <code>body</code> stack program. Applies test to copy of TOS and executes body. Repeats while test is truthy.<!-- -->( -- ? ) |
|  [loopq](./pointfree.loopq.md) | Non-HOF version of [loop](./pointfree.loop.md)<!-- -->. Expects test result and body quotation / word on d-stack.<!-- -->( testq bodyq -- ? ) |
|  [lsl](./pointfree.lsl.md) | ( x y -- x<!-- -->&lt;<!-- -->&lt;<!-- -->y ) |
|  [lsr](./pointfree.lsr.md) | ( x y -- x<!-- -->&gt;<!-- -->&gt;<!-- -->y ) |
|  [lsru](./pointfree.lsru.md) | ( x y -- x<!-- -->&gt;<!-- -->&gt;<!-- -->&gt;<!-- -->y ) |
|  [lt](./pointfree.lt.md) | ( x y -- x<!-- -->&lt;<!-- -->y ) |
|  [lteq](./pointfree.lteq.md) | ( x y -- x<!-- -->&lt;<!-- -->=y ) |
|  [map2](./pointfree.map2.md) | Higher order word. Takes 2 values from d-stack and writes back result from given op. The arg order is (TOS, TOS-1)<!-- -->( a b -- c ) |
|  [mapl](./pointfree.mapl.md) | Generic array transformer.<!-- -->( arr q -- ? )<!-- -->Pops both args from d-stack, then executes quotation for each array item (each pushed on d-stack prior to calling quotation). Can produce any number of results and therefore also be used as filter, mapcat, reduce...
```
// each item times 10
run([[1, 2, 3, 4], [10, mul], mapl])
// [ [ 10, 20, 30, 40 ], [], {} ]

```
Use for filtering:
```
// drop even numbers, duplicate odd ones
run([[1, 2, 3, 4], [dup, even, cond(drop, dup)], mapl])
// [ [ 1, 1, 3, 3 ], [], {} ]

```
Reduction:
```
// the `0` is the initial reduction result
runU([0, [1, 2, 3, 4], [add], mapl])
// 10

```
\*\*Important\*\*: [mapl](./pointfree.mapl.md) does not produce a result array. However, there're several options to collect results as array, e.g.<!-- -->Use [mapll](./pointfree.mapll.md) to transform: |
|  [mapll](./pointfree.mapll.md) | Similar to [mapl](./pointfree.mapl.md)<!-- -->, but produces new array of transformed values.<!-- -->( arr q -- arr ) |
|  [maptos](./pointfree.maptos.md) | Higher order word. Replaces TOS of d-stack with result of given op.<!-- -->( x -- y ) |
|  [max](./pointfree.max.md) | ( x y -- max(x,y) ) |
|  [min](./pointfree.min.md) | ( x y -- min(x,y) ) |
|  [mod](./pointfree.mod.md) | ( x y -- x%y ) |
|  [movdr](./pointfree.movdr.md) |  |
|  [movdr2](./pointfree.movdr2.md) |  |
|  [movrd](./pointfree.movrd.md) |  |
|  [movrd2](./pointfree.movrd2.md) |  |
|  [mul](./pointfree.mul.md) | ( x y -- x\*y ) |
|  [neg](./pointfree.neg.md) | ( x -- -x ) |
|  [neq](./pointfree.neq.md) | ( x y -- x!==y ) |
|  [nip](./pointfree.nip.md) | Removes second topmost item from d-stack.<!-- -->( x y -- y ) |
|  [nop](./pointfree.nop.md) | Utility word w/ no stack nor side effect. |
|  [not](./pointfree.not.md) | ( x -- !x ) |
|  [obj](./pointfree.obj.md) | Pushes new empty JS object on d-stack. Same reasoning as for [list](./pointfree.list.md)<!-- -->.<!-- -->( -- {<!-- -->} ) |
|  [odd](./pointfree.odd.md) | ( x -- bool ) |
|  [oneover](./pointfree.oneover.md) | ( x -- 1/x ) |
|  [op2v](./pointfree.op2v.md) | Similar to [map2](./pointfree.map2.md)<!-- -->, but for array operators. Either <code>a</code> or <code>b</code> can be a non-array value, but not both. Creates new array of result values. The result will have the same length as the shortest arg (if <code>a</code> and <code>b</code> have different lengths).<!-- -->- ( a b -- a ), if <code>a</code> is an array - ( a b -- b ), if <code>a</code> is not an array |
|  [or](./pointfree.or.md) | ( x y -- x\|\|y ) |
|  [over](./pointfree.over.md) | Pushes copy of TOS-1 as new TOS on d-stack.<!-- -->( x y -- x y x ) |
|  [pick](./pointfree.pick.md) | Uses TOS as index to look up a deeper d-stack value, then places it as new TOS. Throws error if stack depth is &lt; <code>x</code>.<!-- -->( ... x -- ... stack\[x\] ) |
|  [popr](./pointfree.popr.md) | Removes RHS from array as new TOS on d-stack. Throws error is <code>arr</code> is empty.<!-- -->( arr -- arr arr\[-1\] ) |
|  [pow](./pointfree.pow.md) | ( x y -- pow(x,y) ) |
|  [print](./pointfree.print.md) | Prints TOS to console<!-- -->( x -- ) |
|  [printds](./pointfree.printds.md) |  |
|  [printrs](./pointfree.printrs.md) |  |
|  [pull](./pointfree.pull.md) |  |
|  [pull2](./pointfree.pull2.md) |  |
|  [pull3](./pointfree.pull3.md) |  |
|  [pull4](./pointfree.pull4.md) |  |
|  [push](./pointfree.push.md) | Higher order word. Pushes given args verbatim on d-stack.<!-- -->( -- ...args ) |
|  [pushenv](./pointfree.pushenv.md) | Pushes current env onto d-stack.<!-- -->( -- env ) |
|  [pushl](./pointfree.pushl.md) | Pushes <code>val</code> on the LHS of array.<!-- -->( val arr -- arr ) |
|  [pushr](./pointfree.pushr.md) | Pushes <code>val</code> on the RHS of array.<!-- -->( arr val -- arr ) |
|  [rand](./pointfree.rand.md) | ( -- Math.random() ) |
|  [rdec](./pointfree.rdec.md) | Like [dec](./pointfree.dec.md)<!-- -->, but applies to r-stack TOS. |
|  [rdrop](./pointfree.rdrop.md) | Removes TOS from r-stack.<!-- -->( x -- ) |
|  [rdrop2](./pointfree.rdrop2.md) | Removes top 2 vals from r-stack.<!-- -->( x y -- ) |
|  [rdup](./pointfree.rdup.md) | Duplicates TOS on r-stack.<!-- -->( x -- x x ) |
|  [rdup2](./pointfree.rdup2.md) | Duplicates top 2 vals on r-stack.<!-- -->( x y -- x y x y ) |
|  [rdup3](./pointfree.rdup3.md) | Duplicates top 3 vals on r-stack.<!-- -->( x y -- x y x y ) |
|  [rinc](./pointfree.rinc.md) | Like [inc](./pointfree.inc.md)<!-- -->, but applies to r-stack TOS. |
|  [rot](./pointfree.rot.md) | Rotates three topmost d-stack items downwards/to the left.<!-- -->( x y z -- y z x ) |
|  [rover](./pointfree.rover.md) | Pushes copy of TOS-1 as new TOS on r-stack.<!-- -->( x y -- x y x ) |
|  [rsp](./pointfree.rsp.md) | Pushes current r-stack size on d-stack.<!-- -->( -- n ) |
|  [rswap](./pointfree.rswap.md) | Swaps the two topmost r-stack items.<!-- -->( x y -- y x ) |
|  [rswap2](./pointfree.rswap2.md) | Swaps the two topmost d-stack pairs.<!-- -->( a b c d -- c d a b ) |
|  [run](./pointfree.run.md) | Executes program / quotation with given stack context (initial D/R stacks and optional environment). Returns updated context. |
|  [runE](./pointfree.rune.md) | Like [run](./pointfree.run.md)<!-- -->, but returns result environment. Syntax sugar for: <code>run(...)[2]</code> |
|  [runU](./pointfree.runu.md) | Like [run](./pointfree.run.md)<!-- -->, but returns unwrapped result. Syntax sugar for: <code>unwrap(run(...),n)</code> |
|  [safeMode](./pointfree.safemode.md) |  |
|  [setat](./pointfree.setat.md) | Writes <code>val</code> at key/index in object/array.<!-- -->( val obj k -- obj ) |
|  [sin](./pointfree.sin.md) | ( x -- sin(x) ) |
|  [split](./pointfree.split.md) | Splits vector / array at given index <code>x</code>.<!-- -->( arr x -- \[...\] \[...\] ) |
|  [sqrt](./pointfree.sqrt.md) | ( x -- sqrt(x) ) |
|  [store](./pointfree.store.md) | Stores <code>val</code> under <code>key</code> in env.<!-- -->( val key -- ) |
|  [storekey](./pointfree.storekey.md) | Higher order word. Similar to [store](./pointfree.store.md)<!-- -->, but always uses given preconfigure <code>key</code> instead of reading it from d-stack at runtime (also slightly faster).<!-- -->( val -- ) |
|  [sub](./pointfree.sub.md) | ( x y -- x-y ) |
|  [swap](./pointfree.swap.md) | Swaps the two topmost d-stack items.<!-- -->( x y -- y x ) |
|  [swap2](./pointfree.swap2.md) | Swaps the two topmost d-stack pairs.<!-- -->( a b c d -- c d a b ) |
|  [tan](./pointfree.tan.md) | ( x -- tan(x) ) |
|  [tanh](./pointfree.tanh.md) | ( x -- tanh(x) ) |
|  [tojson](./pointfree.tojson.md) | ( x -- str ) |
|  [tos](./pointfree.tos.md) | Returns top of stack value (always unsafe, no underflow checking). |
|  [tri](./pointfree.tri.md) | Applies <code>p</code> to <code>x</code>, then <code>q</code> to <code>x</code>, and finally <code>r</code> to <code>x</code>( x p q r -- px qx rx ) |
|  [tri2](./pointfree.tri2.md) | Applies <code>p</code> to the two input values <code>x y</code>, then same with <code>q</code>, and finally with <code>r</code>.<!-- -->( x y p q r -- pxy qxy rxy ) |
|  [tri3](./pointfree.tri3.md) | Applies <code>p</code> to the three input values <code>x y z</code>, then same with <code>q</code>, and finally with <code>r</code>.<!-- -->( x y z p q r -- pxyz qxyz rxyz ) |
|  [tria](./pointfree.tria.md) | Applies the <code>q</code> to <code>x</code>, then to <code>y</code>, and finally to <code>z</code>.<!-- -->( x y z q -- qx qy qz ) |
|  [tria2](./pointfree.tria2.md) | Applies the quotation to <code>u v</code>, then to <code>w x</code>, and then to <code>y z</code>.<!-- -->( u v w x y z q -- quv qwx qyz ) |
|  [tris](./pointfree.tris.md) | Applies <code>p</code> to <code>x</code>, then <code>q</code> to <code>y</code>, and finally <code>r</code> to <code>z</code>.<!-- -->( x y z p q r -- ) |
|  [tris2](./pointfree.tris2.md) | Applies <code>p</code> to <code>u v</code>, then <code>q</code> to <code>w x</code>, and finally <code>r</code> to <code>y z</code>.<!-- -->( u v w x y z p q r -- puv qwx ryz ) |
|  [tuck](./pointfree.tuck.md) | Inserts copy of TOS @ TOS-2 in d-stack.<!-- -->( x y -- y x y ) |
|  [tuple](./pointfree.tuple.md) | Higher order helper word to [collect](./pointfree.collect.md) tuples of pre-defined size <code>n</code>. The size can be given as number or a stack function producing a number.<!-- -->( ... -- \[...\]) |
|  [unwrap](./pointfree.unwrap.md) | Takes a result tuple returned by [run](./pointfree.run.md) and unwraps one or more items from result stack. If no <code>n</code> is given, defaults to single value (TOS) and returns it as is. Returns an array for all other <code>n</code>. |
|  [vadd](./pointfree.vadd.md) |  |
|  [vdiv](./pointfree.vdiv.md) |  |
|  [vec2](./pointfree.vec2.md) |  |
|  [vec3](./pointfree.vec3.md) |  |
|  [vec4](./pointfree.vec4.md) |  |
|  [vmul](./pointfree.vmul.md) |  |
|  [vsub](./pointfree.vsub.md) |  |
|  [whenq](./pointfree.whenq.md) | Similar to [condq](./pointfree.condq.md)<!-- -->, but only expects <code>test</code> result and truthy branch d-stack. Executes word/quotation if <code>test</code> is truthy, else does nothing.<!-- -->( test whenq -- ? ) |
|  [word](./pointfree.word.md) | Higher order word. Takes a StackProgram and returns it as StackFn to be used like any word. Unknown stack effect.<!-- -->If the optional <code>env</code> is given, uses a shallow copy of that environment (one per invocation) instead of the current one passed by [run](./pointfree.run.md) at runtime. If <code>mergeEnv</code> is true (default), the user provided env will be merged with the current env (also shallow copies). This is useful in conjunction with [pushenv](./pointfree.pushenv.md) and [store](./pointfree.store.md) or <code>storekey()</code> to save results of sub procedures in the main env.<!-- -->Note: The provided (or merged) env is only active within the execution scope of the word.<!-- -->( ? -- ? ) |
|  [wordU](./pointfree.wordu.md) | Like [word](./pointfree.word.md)<!-- -->, but automatically calls [unwrap](./pointfree.unwrap.md) on result context to produced unwrapped value/tuple.<!-- -->\*\*Importatant:\*\* Words defined with this function CANNOT be used as part of a larger stack program, only for standalone use. |

## Type Aliases

|  Type Alias | Description |
|  --- | --- |
|  [Stack](./pointfree.stack.md) |  |
|  [StackEnv](./pointfree.stackenv.md) |  |
|  [StackFn](./pointfree.stackfn.md) |  |
|  [StackProc](./pointfree.stackproc.md) |  |
|  [StackProgram](./pointfree.stackprogram.md) |  |

