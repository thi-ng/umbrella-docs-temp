<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/compose](./compose.md)

## compose package

## Classes

|  Class | Description |
|  --- | --- |
|  [Delay](./compose.delay.md) |  |

## Functions

|  Function | Description |
|  --- | --- |
|  [comp(a)](./compose.comp.md) | Returns the right-to-left composition of given functions. I.e. when the composed function is called, the given right most function is called first (supports any number of args) and its return value then used as sole argument for the next function etc. Eventually returns result of left-most function. |
|  [comp(a, b, c, d, e, f, g, h, i, j)](./compose.comp_9.md) |  |
|  [comp(a, b, c, d, e, f, g, h, i, j, fns)](./compose.comp_10.md) |  |
|  [comp(a, b)](./compose.comp_1.md) |  |
|  [comp(a, b, c)](./compose.comp_2.md) |  |
|  [comp(a, b, c, d)](./compose.comp_3.md) |  |
|  [comp(a, b, c, d, e)](./compose.comp_4.md) |  |
|  [comp(a, b, c, d, e, f)](./compose.comp_5.md) |  |
|  [comp(a, b, c, d, e, f, g)](./compose.comp_6.md) |  |
|  [comp(a, b, c, d, e, f, g, h)](./compose.comp_7.md) |  |
|  [comp(a, b, c, d, e, f, g, h, i)](./compose.comp_8.md) |  |
|  [compL(a)](./compose.compl.md) | Similar to <code>comp()</code>, but composes given functions in left-to-right order. |
|  [compL(a, b, c, d, e, f, g, h, i, j)](./compose.compl_9.md) |  |
|  [compL(a, b, c, d, e, f, g, h, i, j, xs)](./compose.compl_10.md) |  |
|  [compL(a, b)](./compose.compl_1.md) |  |
|  [compL(a, b, c)](./compose.compl_2.md) |  |
|  [compL(a, b, c, d)](./compose.compl_3.md) |  |
|  [compL(a, b, c, d, e)](./compose.compl_4.md) |  |
|  [compL(a, b, c, d, e, f)](./compose.compl_5.md) |  |
|  [compL(a, b, c, d, e, f, g)](./compose.compl_6.md) |  |
|  [compL(a, b, c, d, e, f, g, h)](./compose.compl_7.md) |  |
|  [compL(a, b, c, d, e, f, g, h, i)](./compose.compl_8.md) |  |
|  [complement(f)](./compose.complement.md) |  |
|  [complement(f)](./compose.complement_1.md) |  |
|  [complement(f)](./compose.complement_2.md) |  |
|  [complement(f)](./compose.complement_3.md) |  |
|  [complement(f)](./compose.complement_4.md) |  |
|  [complement(f)](./compose.complement_5.md) |  |
|  [complement(f)](./compose.complement_6.md) |  |
|  [complement(f)](./compose.complement_7.md) |  |
|  [complement(f)](./compose.complement_8.md) |  |
|  [juxt(a)](./compose.juxt.md) |  |
|  [juxt(a, b)](./compose.juxt_1.md) |  |
|  [juxt(a, b, c)](./compose.juxt_2.md) |  |
|  [juxt(a, b, c, d)](./compose.juxt_3.md) |  |
|  [juxt(a, b, c, d, e)](./compose.juxt_4.md) |  |
|  [juxt(a, b, c, d, e, f)](./compose.juxt_5.md) |  |
|  [juxt(a, b, c, d, e, f, g)](./compose.juxt_6.md) |  |
|  [juxt(a, b, c, d, e, f, g, h)](./compose.juxt_7.md) |  |
|  [juxt(a, b, c, d, e, f, g, h, xs)](./compose.juxt_8.md) |  |
|  [partial(fn, a)](./compose.partial.md) |  |
|  [partial(fn, a, b)](./compose.partial_1.md) |  |
|  [partial(fn, a, b, c)](./compose.partial_2.md) |  |
|  [partial(fn, a, b, c, d)](./compose.partial_3.md) |  |
|  [partial(fn, a, b, c, d, e)](./compose.partial_4.md) |  |
|  [partial(fn, a, b, c, d, e, f)](./compose.partial_5.md) |  |
|  [partial(fn, a, b, c, d, e, f, g)](./compose.partial_6.md) |  |
|  [partial(fn, a, b, c, d, e, f, g, h)](./compose.partial_7.md) |  |

## Variables

|  Variable | Description |
|  --- | --- |
|  [compI](./compose.compi.md) |  |
|  [constantly](./compose.constantly.md) |  |
|  [delay](./compose.delay.md) |  |
|  [delayed](./compose.delayed.md) |  |
|  [foo](./compose.foo.md) |  |
|  [identity](./compose.identity.md) |  |
|  [ifDef](./compose.ifdef.md) | Returns f(x) iff <code>x</code> is not null or undefined. |
|  [threadFirst](./compose.threadfirst.md) | Takes an <code>init</code> value and a number of functions and/or function tuples, consisting of: <code>[fn, ...args]</code>. Executes each function (or tuple) with the return value of the previous expression inserted as first argument, using <code>init</code> for the first expression.
```ts
const neg = (x) => -x;
const sub = (a, b) => a - b;
const div = (a, b) => a / b;

threadFirst(
  5,
  neg,       // -5
  [sub, 20], // -5 - 20 = -25
  [div, 10]  // -25 / 10 = -2.5
);

// -2.5

```
 threadLast |
|  [threadLast](./compose.threadlast.md) | Takes an <code>init</code> value and a number of functions and/or function tuples, consisting of: <code>[fn, ...args]</code>. Executes each function (or tuple) with the return value of the previous expression inserted as last argument, using <code>init</code> for the first expression.
```ts
const neg = (x) => -x;
const sub = (a, b) => a - b;
const div = (a, b) => a / b;

threadLast(
  5,
  neg,       // -5
  [sub, 10], // 20 - (-5) = 25
  [div, 10]  // 10 / 25 = 0.4
);

// 0.4

```
 threadFirst |
|  [trampoline](./compose.trampoline.md) | Takes a function returning either a no-arg function (thunk) or its already realized (non-function) result. Re-executes thunk for as long as it returns another function/thunk. Once a non-function result has been produced, <code>trampoline</code> returns that value itself. If the final result should be function, it needs to wrapped (e.g. as a 1-elem array).<!-- -->This function should be used for non-stack consuming recursion. I.e. a trampoline is a form of continuation passing style and only ever consumes max. 2 extra stack frames, independent from recursion depth.
```ts
const countdown = (acc, x) =>
  x >= 0 ?
    () => (acc.push(x), countdown(acc, x-1)) :
    acc;

trampoline(countdown([], 4))
// [ 4, 3, 2, 1, 0 ]

trampoline(countdown([], -1))
// []

```
 |

