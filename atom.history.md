<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/atom](./atom.md) &gt; [History](./atom.history.md)

## History class

Undo/redo history stack wrapper for atoms and cursors. Implements [IAtom](./atom.iatom.md) interface and so can be used directly in place and delegates to wrapped atom/cursor.

<b>Signature:</b>

```typescript
export declare class History<T> implements IHistory<T> 
```

## Remarks

Value changes are only recorded in history if `changed` predicate returns truthy value, or else by calling [History.record()](./atom.history.record.md) directly. This class too implements the [INotify](./api.inotify.md) interface to support event listeners for [History.undo()](./atom.history.undo.md)<!-- -->, [History.redo()](./atom.history.redo.md) and [History.record()](./atom.history.record.md)<!-- -->.

## Constructors

|  Constructor | Modifiers | Description |
|  --- | --- | --- |
|  [(constructor)(state, maxLen, changed)](./atom.history._constructor_.md) |  | Constructs a new instance of the <code>History</code> class |

## Properties

|  Property | Modifiers | Type | Description |
|  --- | --- | --- | --- |
|  [changed](./atom.history.changed.md) |  | <code>Predicate2&lt;T&gt;</code> |  |
|  [EVENT\_RECORD](./atom.history.event_record.md) | <code>static</code> | <code></code> |  |
|  [EVENT\_REDO](./atom.history.event_redo.md) | <code>static</code> | <code></code> |  |
|  [EVENT\_UNDO](./atom.history.event_undo.md) | <code>static</code> | <code></code> |  |
|  [future](./atom.history.future.md) |  | <code>T[]</code> |  |
|  [history](./atom.history.history.md) |  | <code>T[]</code> |  |
|  [maxLen](./atom.history.maxlen.md) |  | <code>number</code> |  |
|  [state](./atom.history.state.md) |  | <code>IAtom&lt;T&gt;</code> |  |
|  [value](./atom.history.value.md) |  | <code>T</code> |  |

## Methods

|  Method | Modifiers | Description |
|  --- | --- | --- |
|  [addListener(id, fn, scope)](./atom.history.addlistener.md) |  |  |
|  [addWatch(id, fn)](./atom.history.addwatch.md) |  | <code>IWatch.addWatch()</code> implementation. Delegates to wrapped atom/cursor. |
|  [canRedo()](./atom.history.canredo.md) |  |  |
|  [canUndo()](./atom.history.canundo.md) |  |  |
|  [clear()](./atom.history.clear.md) |  | Clears history &amp; future stacks |
|  [deref()](./atom.history.deref.md) |  | Returns wrapped atom's \*\*current\*\* value. |
|  [notify(e)](./atom.history.notify.md) |  |  |
|  [notifyWatches(oldState, newState)](./atom.history.notifywatches.md) |  | <code>IWatch.notifyWatches()</code> implementation. Delegates to wrapped atom/cursor. |
|  [record(state)](./atom.history.record.md) |  | Records given state in history. This method is only needed when manually managing snapshots, i.e. when applying multiple swaps on the wrapped atom directly, but not wanting to create an history entry for each change. |
|  [redo()](./atom.history.redo.md) |  | Attempts to re-apply most recent value from future stack to atom and returns it if successful (i.e. there's a future). |
|  [release()](./atom.history.release.md) |  |  |
|  [removeListener(id, fn, scope)](./atom.history.removelistener.md) |  |  |
|  [removeWatch(id)](./atom.history.removewatch.md) |  | <code>IWatch.removeWatch()</code> implementation. Delegates to wrapped atom/cursor. |
|  [reset(val)](./atom.history.reset.md) |  | <code>IReset.reset()</code> implementation. Delegates to wrapped atom/cursor, but too applies <code>changed</code> predicate to determine if there was a change and if the previous value should be recorded. |
|  [resetIn(path, val)](./atom.history.resetin.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_9.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_1.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_2.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_3.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_4.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_5.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_6.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_7.md) |  |  |
|  [resetIn(path, val)](./atom.history.resetin_8.md) |  |  |
|  [resetInUnsafe(path, val)](./atom.history.resetinunsafe.md) |  |  |
|  [swap(fn, args)](./atom.history.swap.md) |  | <code>ISwap.swap()</code> implementation. Delegates to wrapped atom/cursor, but too applies <code>changed</code> predicate to determine if there was a change and if the previous value should be recorded. |
|  [swapIn(path, fn, args)](./atom.history.swapin.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_9.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_1.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_2.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_3.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_4.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_5.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_6.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_7.md) |  |  |
|  [swapIn(path, fn, args)](./atom.history.swapin_8.md) |  |  |
|  [swapInUnsafe(path, fn, args)](./atom.history.swapinunsafe.md) |  |  |
|  [undo()](./atom.history.undo.md) |  | Attempts to re-apply most recent historical value to atom and returns it if successful (i.e. there's a history). |

