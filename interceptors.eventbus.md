<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@thi.ng/interceptors](./interceptors.md) &gt; [EventBus](./interceptors.eventbus.md)

## EventBus class

Stateful version of `StatelessEventBus`<!-- -->. Wraps an `IAtom` state container (Atom/Cursor) and provides additional pre-defined event handlers and side effects to manipulate wrapped state. Prefer this as the default implementation for most use cases.

<b>Signature:</b>

```typescript
export declare class EventBus extends StatelessEventBus implements IDeref<any>, IDispatch 
```

## Constructors

|  Constructor | Modifiers | Description |
|  --- | --- | --- |
|  [(constructor)(state, handlers, effects)](./interceptors.eventbus._constructor_.md) |  | Creates a new event bus instance with given parent state, handler and effect definitions (all optional). If no state is given, automatically creates an <code>Atom</code> with empty state object.<!-- -->In addition to the user provided handlers &amp; effects, a number of built-ins are added automatically. See <code>addBuiltIns()</code>. User handlers can override built-ins. |

## Properties

|  Property | Modifiers | Type | Description |
|  --- | --- | --- | --- |
|  [state](./interceptors.eventbus.state.md) |  | <code>IAtom&lt;any&gt;</code> |  |

## Methods

|  Method | Modifiers | Description |
|  --- | --- | --- |
|  [addBuiltIns()](./interceptors.eventbus.addbuiltins.md) |  | Adds same built-in event &amp; side effect handlers as in <code>StatelessEventBus.addBuiltIns()</code> and the following additions:<!-- -->\#\#\# Handlers<!-- -->\#\#\#\# <code>EV_SET_VALUE</code>Resets state path to provided value. See <code>setIn()</code>.<!-- -->Example event definition:
```
[EV_SET_VALUE, ["path.to.value", val]]

```
\#\#\#\# <code>EV_UPDATE_VALUE</code>Updates a state path's value with provided function and optional extra arguments. See <code>updateIn()</code>.<!-- -->Example event definition:
```
[EV_UPDATE_VALUE, ["path.to.value", (x, y) => x + y, 1]]

```
\#\#\#\# <code>EV_TOGGLE_VALUE</code>Negates a boolean state value at given path.<!-- -->Example event definition:
```
[EV_TOGGLE_VALUE, "path.to.value"]

```
\#\#\#\# <code>EV_UNDO</code>Calls <code>ctx[id].undo()</code> and uses return value as new state. Assumes <code>ctx[id]</code> is a [History](./atom.history.md) instance, provided via e.g. <code>processQueue({ history })</code>. The event can be triggered with or without ID. By default <code>&quot;history&quot;</code> is used as default key to lookup the <code>History</code> instance. Furthermore, an additional event can be triggered based on if a previous state has been restored or not (basically, if the undo was successful). This is useful for resetting/re-initializing stateful resources after a successful undo action or to notify the user that no more undo's are possible. The new event will be processed in the same frame and has access to the (possibly) restored state. The event structure for these options is shown below:
```
// using default ID
bus.dispatch([EV_UNDO]);

// using custom history ID
bus.dispatch([EV_UNDO, ["custom"]]);

// using custom ID and dispatch another event after undo
bus.dispatch([EV_UNDO, ["custom", ["ev-undo-success"], ["ev-undo-fail"]]]);

```
\#\#\#\# <code>EV_REDO</code>Similar to <code>EV_UNDO</code>, but for redo actions.<!-- -->\#\#\# Side effects<!-- -->\#\#\#\# <code>FX_STATE</code>Resets state atom to provided value (only a single update per processing frame). |
|  [deref()](./interceptors.eventbus.deref.md) |  | Returns value of internal state. Shorthand for: <code>bus.state.deref()</code> |
|  [processQueue(ctx)](./interceptors.eventbus.processqueue.md) |  | Triggers processing of current event queue and returns <code>true</code> if the any of the processed events caused a state change.<!-- -->If an event handler triggers the <code>FX_DISPATCH_NOW</code> side effect, the new event will be added to the currently processed batch and therefore executed in the same frame. Also see <code>dispatchNow()</code>.<!-- -->If the optional <code>ctx</code> arg is provided it will be merged into the <code>InterceptorContext</code> object passed to each interceptor. Since the merged object is also used to collect triggered side effects, care must be taken that there're no key name clashes.<!-- -->In order to use the built-in <code>EV_UNDO</code>, <code>EV_REDO</code> events, users MUST provide a [History](./atom.history.md) (or compatible undo history instance) via the <code>ctx</code> arg, e.g.
```
bus.processQueue({ history });

```
 |

